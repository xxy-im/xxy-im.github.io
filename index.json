[{"categories":["C++"],"content":"了解右值和右值引用的概念以及移动语义的实现。 右值引用(rvalue reference)，是C++11标准提出的一类数据类型。 可用于实现移动语义(move semantic)与完美转发(perfect forwarding)。 ","date":"2022-04-15","objectID":"/rvalueref/:0:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#"},{"categories":["C++"],"content":"右值 何为右值(r-value)，说人话就是只能放在等号右边的东西。例如int a = 1这个表达式中，a在等号左边，所以a是左值，而1是右值。 右值通常为一个表达式，是赋值计算产生临时生成的中间变量。 ","date":"2022-04-15","objectID":"/rvalueref/:1:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#右值"},{"categories":["C++"],"content":"右值引用 C++中，通常的引用是指左值引用，用符号\u0026表示，而右值引用符号为\u0026\u0026。 int a = 1; int\u0026 ref = a; // 左值引用 在上述代码中，定义了一个对a的左值引用，但是\u0026符号不能对1引用，int \u0026ref = 1的非法的。 但是可以使用int \u0026\u0026ref = 1，定义一个对1的右值引用。 int a = 1; int\u0026 ref = a; // 左值引用 // int\u0026 ref = 1; // error int\u0026\u0026 rref = 1; // 右值引用 // int\u0026\u0026 r_ref = a; // error，右值引用不可指向左值 r_ref = 2; // 右值引用也可以修改值 可以看出来这里的右值引用自身是一个左值（有名字的右值引用自身是左值）。 ","date":"2022-04-15","objectID":"/rvalueref/:2:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#右值引用"},{"categories":["C++"],"content":"std::move std::move一般理解为移动操作，在PImpl讲过的std::unique_ptr这个智能指针是禁止拷贝的，这是便可使用std::move对其进行移动操作。但std::move的原理是将左值转化为右值，底层操作中并没有实现内存的移动啥的。（如果没理解的话这就是个坑） int a = 1; int\u0026 ref = a; int\u0026\u0026 r_ref = std::move(a); // 将a转化为左值 与 int\u0026\u0026 rref = 1 等价 r_ref = 2; // 等价 a = 2 但是和int\u0026\u0026 rref = 1不同的是，此时r_ref也相当于a的一个左值引用。同时可以看出std::move根本没把a给移掉，因为像int这样的基本类型std::move对其是没有影响的。像string、std::unique_ptr这样的move就会变空了。要养成移动后不在使用的习惯 ","date":"2022-04-15","objectID":"/rvalueref/:2:1","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#stdmove"},{"categories":["C++"],"content":"右值引用作函数参数 void func(int \u0026\u0026v) { // do something } int a = 1; func(std::move(a)); // ok func(2); // ok 单从性能上来看，左右值引用都避免了传参拷贝。 顺带提一下，C++规定 \u0026\u0026 可以自动转化为const\u0026，所以当形参为void func(int const\u0026 v)时调用func(2)其实是隐含了一个转换。但右值引用比const引用更灵活，因为它还是可以修改的。 ","date":"2022-04-15","objectID":"/rvalueref/:2:2","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#右值引用作函数参数"},{"categories":["C++"],"content":"移动语义 ","date":"2022-04-15","objectID":"/rvalueref/:3:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#移动语义"},{"categories":["C++"],"content":"移动构造函数 在PImpl中也可以看到widget类中移动构造函数的参数为右值引用。 class widget { class impl; std::unique_ptr\u003cimpl\u003e pImpl; public: widget(); explicit widget(int); ~widget(); widget(widget\u0026\u0026); // 移动构造 widget(const widget\u0026) = delete; widget\u0026 operator=(widget\u0026\u0026); // 移动赋值 widget\u0026 operator=(const widget\u0026) = delete; }; int main() { widget w; widget wm = widget(std::move(w)); // do something } 这样做的好处同样是比用const引用更加灵活，可以做浅拷贝提升性能。 ","date":"2022-04-15","objectID":"/rvalueref/:3:1","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#移动构造函数"},{"categories":["C++"],"content":"容器避免深拷贝 STL类大都支持移动语义函数，比如vector就可以用std::move避免深拷贝以提升性能 std::vector\u003cstd::string\u003e sVec; std::string str = \"hello\"; sVec.push_back(std::move(str)); // 避免是对str的拷贝，性能得到提升 可移动对象在需要拷贝且被拷贝者之后不再被需要的场景，可以使用std::move触发移动语义，提升性能。 ","date":"2022-04-15","objectID":"/rvalueref/:3:2","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#容器避免深拷贝"},{"categories":["C++"],"content":"其他 ","date":"2022-04-15","objectID":"/rvalueref/:4:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#其他"},{"categories":["C++"],"content":"std::forward std::forward叫做完美转发，和std::move一样，这货跟转发没半毛钱关系。也是用于类型转换。 它不仅可以把左值转为右值，还可以反过来把右值转为左值。 使用方法： std::forward\u003cT\u003e(v); // 1. 当T为左值引用时，v被转换为T类型的左值引用 // 2. 否则，v转换为T类型的右值引用 这东西使用场景不多，我也不太懂，就不多做介绍了。 更多右值引用技巧可看这个 https://zhuanlan.zhihu.com/p/107445960 ","date":"2022-04-15","objectID":"/rvalueref/:4:1","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] 右值引用与移动语义","uri":"/rvalueref/#stdforward"},{"categories":["C++"],"content":"“Pointer to implementation”, 指向实现的指针。将一个类的实现细节从其对象中移除，也是一种解耦方法。 ","date":"2022-04-14","objectID":"/pimpl/:0:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] PImpl","uri":"/pimpl/#"},{"categories":["C++"],"content":"PImpl 使用私有的成员指针指向类的成员，是一种实现数据隐藏，最小化耦合和分离接口的现代C++编程技巧。 先看一段官方的PImpl代码 // interface (widget.h) class widget { // public members private: struct impl; std::unique_ptr\u003cimpl\u003e pImpl; }; // implementation (widget.cpp) struct widget::impl { // implementation details }; 可以看到widget类中使用了一个unique指针指向impl这个内部类。这样的好处主要有: ABI(Application Binary Interface, 二进制接口) 稳定，即不会打破二进制兼容。 降低编译依赖项，缩短编译时间。更改成员及实现时只需重新编译成员的源文件，而不需要重新编译所有使用了这个类的用户。 接口与实现分离，提高接口的稳定性。 降低耦合性。 将实现隐藏，头文件变得整洁。 主要缺点是性能会受点影响，因为成员都是用指针间接访问的。 ","date":"2022-04-14","objectID":"/pimpl/:0:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] PImpl","uri":"/pimpl/#pimpl"},{"categories":["C++"],"content":"std::unique_ptr 可以看到上面的代码使用的std::unique_ptr这个智能指针。这是C++11中基于RAII(Resource acquisition is initialization)思想引入的一个智能指针。例如，定义指针p std::unique_ptr\u003cT\u003e p = std::make_unique\u003cT\u003e()，这时就不需要手动管理p指向的内存了，因为std::unique_ptr的析构函数会自动调用delete p。 需要注意的是 std::unique_ptr是禁止拷贝的，所以widget也无法使用拷贝构造函数，但可以使用移动构造函数。 ","date":"2022-04-14","objectID":"/pimpl/:1:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] PImpl","uri":"/pimpl/#stdunique_ptr"},{"categories":["C++"],"content":"完善实现 因为类的定义中还有一个未实现的内部类，所以widget并不是一个完整的类，因此编译器不能为其自动生成构造和析构函数。此时需要在widget.cpp中显示的定义它的构造和析构函数，即使是使用=default也必须放在cpp中。 PImpl的完整代码： 引用自:en.cppreference.com/w/cpp/language/pimpl // interface (widget.hpp) #include \u003ciostream\u003e#include \u003cmemory\u003e class widget { class impl; std::unique_ptr\u003cimpl\u003e pImpl; public: widget(); explicit widget(int); ~widget(); widget(widget\u0026\u0026); // 移动构造 widget(const widget\u0026) = delete; widget\u0026 operator=(widget\u0026\u0026); // 移动赋值 widget\u0026 operator=(const widget\u0026) = delete; }; // --------------------------- // implementation (widget.cpp) // #include \"widget.hpp\" class widget::impl { int n; // private data public: impl(int n) : n(n) {} }; void widget::draw() const { pImpl-\u003edraw(*this); } void widget::draw() { pImpl-\u003edraw(*this); } widget::widget() = default; widget::widget(int n) : pImpl{std::make_unique\u003cimpl\u003e(n)} {} widget::widget(widget\u0026\u0026) = default; widget::~widget() = default; widget\u0026 widget::operator=(widget\u0026\u0026) = default; ","date":"2022-04-14","objectID":"/pimpl/:2:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] PImpl","uri":"/pimpl/#完善实现"},{"categories":["C++"],"content":"其他 一般来说，工厂模式也能消除接口实现的编译时依赖，但工厂模式不是ABI稳定的，因为需要修改虚函数表。 PImpl类是对移动友好的；把大型的类重构为可以移动的PImpl，可以提升容器进行操作的算法性能，但也具有额外的运行时开销，因为任何在被移动对象上允许使用并需要访问私有实现的公开成员函数都必须进行空指针检查。 ","date":"2022-04-14","objectID":"/pimpl/:3:0","series":null,"tags":["C++","编程技巧"],"title":"[C++技法] PImpl","uri":"/pimpl/#其他"},{"categories":["杂记随想"],"content":"Course 6125021 Combinatorics Homework 1，武士数独 数独求解，第一个想到的方法就是DFS回溯。但是简单回溯法在求解单个数独时效率还能接受，放在五重数独（武士数独）上可以就有点差强人意了。我要是用它来解武士数独的话也没必要为这道题写篇博客了 🐱。 ","date":"2021-09-26","objectID":"/samurai-sudoku/:0:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#"},{"categories":["杂记随想"],"content":"开搞 在此之前又仔细学习了一遍DancingLinks。DLX算法解数独的关键在于将数独转化为精确覆盖问题，这一步在单个矩阵的情况下还是比较容易的，但在武士数独上就比较繁琐了。 ","date":"2021-09-26","objectID":"/samurai-sudoku/:0:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#开搞"},{"categories":["杂记随想"],"content":"定义数据结构 const static int SAMURAI_EDGE = 21; const static int SAMURAI_MATRIX = 441; const static int SAMURAI_ROWS = 405; const static int SUDOKU_EDGE = 9; const static int SUDOKU_MATRIX = 81; const static int COLUMN_SIZE = 1692; class DLNode { public: DLNode * Left; // 左结点 DLNode *Right; // 右结点 DLNode *Up; // 上结点 DLNode *Down; // 下结点 DLNode *Col; // 所属列结点 int row; // 行号 int nums; // 该列存在的结点个数（当结点为列结点时有效，否则为-1） DLNode(DLNode *Col, int n, int s = -1): Left(this), Right(this), Up(this), Down(this), Col(Col), row(n), nums(s){ if (Col) Col-\u003eAdd2Colume(this); }; ~DLNode() {}; void Add2Row(DLNode *node); // 添加结点到该行末尾 void Add2Colume(DLNode *node); // 添加结点到该列尾 void RemoveCol(); // 移除该结点所在的列 void RecoverCol(); // 还原列 void Remove(); // 移除该结点关联的行和列 }; class DancingLinks { public: DancingLinks(int s[SAMURAI_EDGE][SAMURAI_EDGE]); ~DancingLinks(); DLNode *Head; std::vector\u003cDLNode *\u003e Cols; // 列向量 std::vector\u003cDLNode *\u003e Ans; // 保存结果 bool DLX(); // DLX算法求解 void ShowResult(int result[SAMURAI_MATRIX]); // 输出结果 }; 数独规则: 每个格子只能填一个数字 每行每个数字只能填一遍(1-9) 每列每个数字只能填一遍(1-9) 每宫每个数字只能填一遍(1-9) ","date":"2021-09-26","objectID":"/samurai-sudoku/:1:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#定义数据结构"},{"categories":["杂记随想"],"content":"武士数独精确覆盖问题 武士数独有五个数独组成，需要 $21 \\times 21$ 大小的矩阵存储数据，即 $441$ 个元素。给五个数独编号 武士数独编号点击放大 \" 武士数独编号 ","date":"2021-09-26","objectID":"/samurai-sudoku/:2:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#武士数独精确覆盖问题"},{"categories":["杂记随想"],"content":"约束定义（索引从0开始） 定义441列 第0列：表示位置(0, 0)填了一个数字 第1列：表示位置(0, 1)填了一个数字 . . . . . . 第20列：表示位置(0, 20)填了一个数字 第21列：表示位置(1, 0)填了一个数字 . . . . . . 第440列：表示位置(20, 20)填了一个数字 位置$(X,Y)$, $Col = X \\times 21 + Y$ 定义405列（5个数独，总共45行） 第441列：0号数独的第0行填了数字1 第442列：0号数独的第0行填了数字2 . . . . . . 第449列：0号数独的第0行填了数字9 第450列：0号数独的第1行填了数字1 . . . . . . 第845列：4号数独的第8行填了数字9 第N列定义为 第$S$号数独$X$行填了数字$Y$，它们之间的关系为 $N = 441 + S \\times 81 + X \\times 9 + (Y-1)$ 定义405列（5个数独，总共45列） 第846列：0号数独的第0列填了数字1 第847列：0号数独的第0列填了数字2 . . . . . . 第857列：0号数独的第0列填了数字9 第858列：0号数独的第1列填了数字1 . . . . . . 第1250列：4号数独的第8列填了数字9 第N列定义为 第$S$号数独$X$列填了数字$Y$，它们之间的关系为 $N = 441 + 405 + S \\times 81 + X \\times 9 + (Y-1)$ 定义441列（$21\\times21$矩阵，总共49个宫,为方便计算没有删去空白的宫） 第1251列：第0宫填了数字1 第1252列：第0宫填了数字2 . . . . . . 第1259列：第0宫填了数字9 第1260列：第1宫填了数字1 . . . . . . 第1691列：第48宫填了数字9 第N列定义为 第$S$宫填了数字$D$,它们之间的关系为 $N = 441 + 405 + 405 + S \\times 9 + (D-1)$ 由上1692列完成了对武士数独的精确覆盖问题约束定义 ","date":"2021-09-26","objectID":"/samurai-sudoku/:3:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#约束定义索引从0开始"},{"categories":["杂记随想"],"content":"初始化Dancing Links 用上图数独为例，(0, 0) 位置为 9，转换为DancingLinksz中的一行，则第0，449, 857, 1259列为 1 (即存在结点)，其余列为 0。 Dancing Links初始化 DancingLinks::DancingLinks(int sam[SAMURAI_EDGE][SAMURAI_EDGE]) { Head = new DLNode(nullptr, 0); // 创建列结点 1692个 for (int i = 0; i \u003c COLUMN_SIZE; i++) { auto t = new DLNode(nullptr, 0, 0); Head-\u003eAdd2Row(t); Cols.push_back(t); } std::vector\u003cDLNode *\u003e Rows; // 保存初始已存在数字的结点 for (int r = 0; r \u003c SAMURAI_EDGE; r++) { for (int c = 0; c \u003c SAMURAI_EDGE; c++) { for (int d = 0; d \u003c SUDOKU_EDGE; d++) { // 计算行数 int row = (r * SAMURAI_EDGE * SUDOKU_EDGE) + (c * SUDOKU_EDGE) + d; int sq = (c / 3) + ((r / 3) * 7); int t = VALID_SQUARE[sq]; if (t \u003e 0) { auto node = new DLNode(Cols[r * SAMURAI_EDGE + c], row); for (int i = 0; i \u003c 2; i++) { // 判断sq号宫属于第几号数独 int sd = (t \u003e 5 \u0026\u0026 !i) ? 4 : t-1; // 当前r，c属于sd号数独的几行几列 //（感觉用数组索引更方便， 一开始我是直接硬算行列，后来在网上看到有人用数组的方式实现） int sdr = SUDOKU_ROW[sd][r]; int sdc = SUDOKU_COLUMN[sd][c]; // 五个数独 总共45行 1-9数字情况 405列 node-\u003eAdd2Row(new DLNode(Cols[SAMURAI_MATRIX + (sd * SUDOKU_MATRIX) + (sdr * SUDOKU_EDGE) + d], row)); node-\u003eAdd2Row(new DLNode(Cols[SAMURAI_MATRIX + SAMURAI_ROWS + (sd * SUDOKU_MATRIX) + (sdc * SUDOKU_EDGE) + d], row)); if (t \u003c 6) i++; t -= 5; } node-\u003eAdd2Row(new DLNode(Cols[SAMURAI_MATRIX + SAMURAI_ROWS + SAMURAI_ROWS + (sq * SUDOKU_EDGE) + d], row)); if (sam[r][c] == (d + 1)) { Rows.push_back(node); } } } } } for (auto col = Head-\u003eRight; col != Head; col = col-\u003eRight) { if (!col-\u003enums) col-\u003eRemoveCol(); } for (auto iter = Rows.begin(); iter != Rows.end(); iter++) { (*iter)-\u003eRemove(); Ans.push_back(*iter); } } 算法执行过程 bool DancingLinks::DLX() { if (Head-\u003eRight == Head) { auto result = new int[Ans.size()]; for (int i = 0; i \u003c Ans.size(); i++) { result[i] = Ans[i]-\u003erow; } ShowResult(result); return true; } DLNode *col = nullptr; int min = INT_MAX; // 找到列元素最少的列 for (auto c = Head-\u003eRight; c != Head; c = c-\u003eRight) { if (min \u003e c-\u003enums) { col = c; min = c-\u003enums; } } col-\u003eRemoveCol(); for (auto node = col-\u003eDown; node != col; node = node-\u003eDown) { Ans.push_back(node); for (auto rnode = node-\u003eRight; rnode != node; rnode = rnode-\u003eRight) { rnode-\u003eCol-\u003eRemoveCol(); } if (DLX()) return true; for (auto lnode = node-\u003eLeft; lnode != node; lnode = lnode-\u003eLeft) { lnode-\u003eCol-\u003eRecoverCol(); } Ans.pop_back(); } col-\u003eRecoverCol(); return false; } ","date":"2021-09-26","objectID":"/samurai-sudoku/:3:1","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#初始化dancing-links"},{"categories":["杂记随想"],"content":"结果输出 数独一： 武士数独1点击放大 \" 武士数独1 数独二： 武士数独2点击放大 \" 武士数独2 ","date":"2021-09-26","objectID":"/samurai-sudoku/:0:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#结果输出"},{"categories":["杂记随想"],"content":"完整代码 https://github.com/xxy-im/SudokuNinja （代码持续优化中） ","date":"2021-09-26","objectID":"/samurai-sudoku/:0:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#完整代码"},{"categories":["杂记随想"],"content":"小结 其本质虽然还是DFS回溯，但是在Dancing Links这一数据结构的加持下，回溯效率大大提升，求解时间小于0.1s，在内存暴增的年代，用些许内存的占用去换取运行时间的加速还是划算的。 后续计划在此基础上增加OCR功能，并优化代码使其适配任意形状数独 （没时间就算了）。 ","date":"2021-09-26","objectID":"/samurai-sudoku/:0:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#小结"},{"categories":["杂记随想"],"content":"参考文章 https://en.wikipedia.org/wiki/Dancing_Links https://www.cnblogs.com/grenet/p/3163550.html https://www.acwing.com/solution/acwing/content/3843/ ","date":"2021-09-26","objectID":"/samurai-sudoku/:0:0","series":null,"tags":["数据结构","算法"],"title":"武士数独(五重数独) 舞蹈链解法","uri":"/samurai-sudoku/#参考文章"},{"categories":["杂记随想"],"content":"计算机程序设计艺术，第四卷第五册C，Dancing Links(舞蹈链算法) Dancing Links (舞蹈链)，是大名鼎鼎的 高德纳(Donald Knuth) 为快速实现他提出的X算法所提出的一种数据结构，所以也叫做 DLX算法，其目的是用于解决 精确覆盖问题。 ","date":"2021-09-22","objectID":"/dancinglinks/:0:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#"},{"categories":["杂记随想"],"content":"覆盖问题 集合$S = \\lbrace1, 2, 3, 4, 5, 6, 7\\rbrace$，有其子集 $S_1 = \\lbrace3, 5\\rbrace$ $S_2 = \\lbrace1, 4, 7\\rbrace$ $S_3 = \\lbrace2, 3, 6\\rbrace$ $S_4 = \\lbrace1, 4, 6\\rbrace$ $S_5 = \\lbrace2, 7\\rbrace$ $S_6 = \\lbrace4, 5, 7\\rbrace$ 选择一些子集组成集合 $T$ ，使得 $T$ 中的包含的元素能覆盖集合 $S$ ，即 $S$ 中的所有元素都能在 $T$ 中找到包含它的子集（$\\forall x \\in S \\rightarrow \\forall x \\in T$）。 重复覆盖： 集合 $S$ 中的任意成员 $x$ 允许同时属于两个以上的子集，例如 $T=\\lbrace S_1, S_2, S_3\\rbrace$ 重复覆盖S。 精确覆盖： 集合 $S$ 中的任意成员 $x$ 属于且只属于 $T$ 中的一个子集，例如 $T=\\lbrace S_1, S_4, S_5\\rbrace$ 精确覆盖S。 用矩阵表示上述问题： 算法步骤如下： 如果矩阵 $A$ 为空且所有列都被选中，则当前局部解即为问题的一个解，返回成功；否则继续。 根据一定方法选择第 $c$ 列。如果某一列中没有1，则返回失败，并去除当前局部解中最新加入的行。 选择第 $r$ 行，使得 $A_{(r,c)} = 1$（该步是不确定的）。 将第 $r$ 行加入当前局部解中。 对于满足 $A_{(r,j)} = 1$ 的每一列 $j$，从矩阵 $A$ 中删除所有满足$A_{(i,j)} = 1$的行，最后再删除第 $j$ 列。 对所得比 $A$ 小的新矩阵递归地执行此算法。 $$ %S = % \\begin{pmatrix} % 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0\\\\ % 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1\\\\ % 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ % 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0\\\\ % 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1\\\\ % 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ % \\end{pmatrix} $$ 即选出矩阵的若干行，使得其中的1在所有列中出现且仅出现一次 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{7}\\\\ \\hline \\mathbf{\\textcolor{blue}{S_1}} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0}\\\\ \\hline \\mathbf{S_2} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_3} \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_4}} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0}\\\\ \\hline \\mathbf{\\textcolor{blue}{S_5}} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1}\\\\ \\hline \\mathbf{S_6} \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 蓝色标记的三行($S_1, S_4, S_5$)，便是精确覆盖问题的解 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{7}\\\\ \\hline \\mathbf{\\textcolor{blue}{S_1}} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0}\\\\ \\mathbf{\\textcolor{blue}{S_4}} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0}\\\\ \\mathbf{\\textcolor{blue}{S_5}} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1}\\\\ \\hline \\end{array} $$ 肉眼很容易一眼看出答案，但是计算机需要具体的算法步骤才行。下面看看 X算法 是如何求解的。 ","date":"2021-09-22","objectID":"/dancinglinks/:0:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#覆盖问题"},{"categories":["杂记随想"],"content":"X算法（DFS回溯） 初始状态： $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{7}\\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0\\\\ \\hline \\mathbf{S_2} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_3} \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_4} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_5} \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_6} \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 高德纳建议每次选取 1 最少的列 X算法的执行步骤如下： 第一步： 选取1最少的列，此时第1，2，3，5，6列1的个数都是2，选择第1列。第1列中 $S_2$ 和 $S_4$均为1，选择 $S_2$ 加入当前解。（$T=\\lbrace S_2\\rbrace$） $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{\\textcolor{blue}{1}} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{\\textcolor{blue}{4}} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{\\textcolor{blue}{7}}\\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_2}} \u0026 \\textcolor{blue}{1} \u0026 0 \u0026 0 \u0026 \\textcolor{blue}{1} \u0026 0 \u0026 0 \u0026 \\textcolor{blue}{1}\\\\ \\hline \\mathbf{S_3} \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_4} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_5} \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_6} \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 第二步： 第1列中$S_2$行和$S_4$行为1，第4列中$S_2$，$S_4$和$S_6$行为1，第7列中$S_2$，$S_5$和$S_6$行为1。所以移除第1，4，7列和$S_2$，$S_4$，$S_5$，$S_6$行。 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{\\textcolor{blue}{1}} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{\\textcolor{blue}{4}} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{\\textcolor{blue}{7}}\\\\ \\hline \\mathbf{S_1} \u0026 \\textcolor{blue}0 \u0026 0 \u0026 1 \u0026 \\textcolor{blue}0 \u0026 1 \u0026 0 \u0026 \\textcolor{blue}0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_2}} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}{1}\\\\ \\hline \\mathbf{S_3} \u0026 \\textcolor{blue}0 \u0026 1 \u0026 1 \u0026 \\textcolor{blue}0 \u0026 0 \u0026 1 \u0026 \\textcolor{blue}0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_4}} \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_5}} \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1\\\\ \\hline \\mathbf{\\textcolor{blue}{S_6}} \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1\\\\ \\hline \\end{array} $$ 第三步： 此时只剩下了$S_1$和$S_3$行可选，矩阵非空，算法继续执行递归回到第一步，此时初始状态如下。 $$ \\begin{array}{|c|c|c|c|c|} \\hline \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 1 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_3} \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 第一步： 此时第2，5，6列1的个数最少，选取第2列，即将对应的 $S_3$ 加入当前解。 （$T=\\lbrace S_2, S_3 \\rbrace$） $$ \\begin{array}{|c|c|c|c|c|} \\hline \u0026 \\mathbf{\\textcolor{blue}{2}} \u0026 \\mathbf{\\textcolor{blue}{3}}\u0026 \\mathbf{5} \u0026 \\mathbf{\\textcolor{blue}{6}} \\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 1 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_3}} \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}1 \u0026 0 \u0026 \\textcolor{blue}1\\\\ \\hline \\end{array} $$ 第二步： 移除 $S_3$ 关联的行列。 $$ \\begin{array}{|c|c|c|c|c|} \\hline \u0026 \\mathbf{\\textcolor{blue}{2}} \u0026 \\mathbf{\\textcolor{blue}{3}} \u0026 \\mathbf{5} \u0026 \\mathbf{\\textcolor{blue}{6}} \\\\ \\hline \\mathbf{\\textcolor{blue}{S_1}} \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0\\\\ \\hline \\mathbf{\\textcolor{blue}{S_3}} \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}1 \u0026 \\textcolor{blue}0 \u0026 \\textcolor{blue}1\\\\ \\hline \\end{array} $$ 第三步： 矩阵为空，但是第5列仍没被选择，所以求解失败，需要回溯到新的行加入解集之前一步，并作另一选择再次执行算法。 $$ \\begin{array}{|c|} \\hline \\mathbf{5}\\\\ \\hline \\end{array} $$ 回溯： $$ \\begin{array}{|c|c|c|c|c|} \\hline \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 1 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_3} \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 第一步： 因为之前在这一步选择了 $S_3$，所以这次我们选择 $S_1$ 加入局部最优解，即（$T=\\lbrace S_1, S_2 \\rbrace$）。 $$ \\begin{array}{|c|c|c|c|c|} \\hline \u0026 \\mathbf{2} \u0026 \\mathbf{\\textcolor{blue}{3}} \u0026 \\mathbf{\\textcolor{blue}","date":"2021-09-22","objectID":"/dancinglinks/:0:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#x算法dfs回溯"},{"categories":["杂记随想"],"content":"Dancing Links 上述回溯求解过程存在大量的缓存矩阵和回溯矩阵的过程。而简单DFS回溯在这些过程中需要不断的删除又创建矩阵，当递归深度过深时还有可能栈溢出。于是算法大师高德纳提出了DLX(Dancing Links X)算法，即使用 Dancing Links 这一数据结构实现X算法。使得整个回溯算法过程中只需要使用一个矩阵链。算法执行过程中，指针在数据之间跳跃着，就像精巧设计的舞蹈一样，故称之为 Dancing Links (舞蹈链)。 舞蹈链的核心是双向链表实现的，先来看看双向链表的删除和插入操作。 双向链表点击放大 \" 双向链表 双向链表中任一元素都能很容易得到它左右两边（Left和Right指针）的元素。 删除Col2： Col1.Right = Col3; Col3.Left = Col1; // delete Col2; 此时我们并没有真的将Col2删除，只是链表遍历不到它了 插入Col2： Col1.Right = Col2; Col3.Left = Col2; 可以看出上面删除和插入都是 $O(1)$ 的。仔细想想这两个操作是不是和算法过程中的缓存，回溯对应。所以我们可以用链表的删除和插入来代替回溯算法中的缓存和回溯过程，且不需要开辟新的内存空间。 ","date":"2021-09-22","objectID":"/dancinglinks/:0:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#dancing-links"},{"categories":["杂记随想"],"content":"数据结构定义 Dancing Links使用的是十字交叉双向循坏列表，即每个结点除了 Left, Right 指针外还存在 Up, Down 指针。同时还有一个指针指向所在的列结点。还需要一个Head结点，当Head-\u003eRight == Head 为 true 时，求解结束。（Head 结点只有 Left, Right 两个有效指针） class DLNode { public: DLNode * Left; // 左结点 DLNode *Right; // 右结点 DLNode *Up; // 上结点 DLNode *Down; // 下结点 DLNode *Col; // 所属列结点 int row; // 行号 int nums; // 该列存在的结点个数（当结点为列结点时有效，否则为-1） DLNode(DLNode *Col, int n, int s = -1): Left(this), Right(this), Up(this), Down(this), Col(Col), row(n), nums(s){ if (Col) Col-\u003eAdd2Colume(this); }; ~DLNode() {}; void Add2Row(DLNode *node); // 添加结点到该行末尾 void Add2Colume(DLNode *node); // 添加结点到该列尾 void RemoveCol(); // 移除该结点所在的列 void RecoverCol(); // 还原列 void Remove(); // 移除该结点关联的行和列 }; class DancingLinks { public: DancingLinks(int s[M][N]); ~DancingLinks(); DLNode *Head; // 头结点 std::vector\u003cDLNode *\u003e Cols; // 列向量 std::vector\u003cDLNode *\u003e Ans; // 保存结果 bool DLX(); // DLX算法求解 void ShowResult(); // 输出结果 }; 根据前面的精确覆盖问题构建Dancing Links结构。 Dancing Links结构图点击放大 \" Dancing Links结构图 ","date":"2021-09-22","objectID":"/dancinglinks/:1:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#数据结构定义"},{"categories":["杂记随想"],"content":"DLX算法求解过程 首先判断 Head-\u003eRight == Head，若为真，求解完成，输出结果。否则算法继续执行。执行过程与前面所述的X算法类似，因此不再赘述。 代码如下： // 初始化Dancing Links DancingLinks::DancingLinks(int s[M][N]) { Head = new DLNode(nullptr, 0); // N列，创建N个列结点 for (int i = 0; i \u003c N; i++) { auto t = new DLNode(nullptr, 0, 0); Head-\u003eAdd2Row(t); Cols.push_back(t); } for (int r = 0; r \u003c M; r++) { bool flag = false; DLNode *node = nullptr; for (int c = 0; c \u003c N; c++) { // 创建结点 if (s[r][c]) { // 该行的第一个结点 if (!flag) { node = new DLNode(Cols[c], r+1); flag = true; } node-\u003eAdd2Row(new DLNode(Cols[c], r+1)); } } } // 移除初始为空的列 for (auto col = Head-\u003eRight; col != Head; col = col-\u003eRight) { if (!col-\u003enums) col-\u003eRemoveCol(); } } // DLX算法 bool DancingLinks::DLX() { if (Head-\u003eRight == Head) { ShowResult(); return true; } DLNode *col = nullptr; int min = INT_MIN; // 找到列元素最少的列 for (auto c = Head-\u003eRight; c != Head; c = c-\u003eRight) { if (min \u003e c-\u003enums) { col = c; min = c-\u003enums; } } col-\u003eRemoveCol(); for (auto node = col-\u003eDown; node != col; node = node-\u003eDown) { Ans.push_back(node); for (auto rnode = node-\u003eRight; rnode != node; rnode = rnode-\u003eRight) { rnode-\u003eCol-\u003eRemoveCol(); } if (DLX()) return true; for (auto lnode = node-\u003eLeft; lnode != node; lnode = lnode-\u003eLeft) { lnode-\u003eCol-\u003eRecoverCol(); } Ans.pop_back(); } col-\u003eRecoverCol(); } 程序完整代码： https://github.com/xxy-im/DancingLinks ","date":"2021-09-22","objectID":"/dancinglinks/:2:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#dlx算法求解过程"},{"categories":["杂记随想"],"content":"参考文章 https://en.wikipedia.org/wiki/Dancing_Links https://www.cnblogs.com/grenet/p/3163550.html ","date":"2021-09-22","objectID":"/dancinglinks/:0:0","series":null,"tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/#参考文章"},{"categories":["杂记随想"],"content":"这是一篇关于一道算法课课后作业解题过程的一些思考 最近开始上算法设计与分析课，课后老师布置了一道关于时间复杂度的编程题。题目应该是老师自己编的。说实话，时间复杂度这种东西以前从来没有重视过，只停留根据代码判断程序时间复杂度的阶段。所以一开始也觉得做这种题目真是浪费时间(当然现在好像也觉得这题目没什么卵用)。 题目如下： 为了简单，只考虑6种算法的时间复杂度类型，分别为O(n)，O(nlogn)，O(n^2)，O(n^3)，O(2^n)和O(n!)。现有大量运行结果，请你根据运行结果判断复杂度类型。 输入： 第一行：一个整数k，表明有k对运行数据（n, t），n为运行规模，t为运行时间，都是整数。 第二行：k个整数，为运行规模，整数（\u003c1000001），每个数据之间有一个空格 第三行：k个整数，为运行时间，整数（\u003c100000），每个数据之间有一个空格 重复这三行，直至k=0。 输出： 每个例子输出一个整数（1-6之间），占一行，1,2,3,4,5,6分别代表复杂度类型O(n)，O(nlogn)，O(n^2)，O(n^3)，O(2^n)和O(n!)。最后一个例子也有回车 输入实例: 4 8 10 11 9 0 375 4218 31 6 17 20 24 19 22 25 16 110 1703 47 406 3468 5 359999 431998 518397 300000 746491 31 47 47 31 78 0 输出示例: 6 5 2 ","date":"2021-09-16","objectID":"/time-complexity/:0:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#"},{"categories":["杂记随想"],"content":"思考 ","date":"2021-09-16","objectID":"/time-complexity/:0:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#思考"},{"categories":["杂记随想"],"content":"探索一： 第一眼看到题目的时候一边想着这什么鬼一边又觉得这题目还挺新颖的。首先想到的是从运行规模之间的差值和运行时间的比值这方面下手。感觉这也是很多同学一开始的思路，然后做着做着发现这样的做法好像不需要用到k组数据呀，不是两组就行了吗。不管了，先做下去吧。代码写完，用实例测一遍，emmmmmm… 没过，不管先去页面上run一次。好家伙，一组数据都没通过。 提交运行点击放大 \" 提交运行 ","date":"2021-09-16","objectID":"/time-complexity/:1:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#探索一"},{"categories":["杂记随想"],"content":"探索二： 我真的太菜了，实在不行我做下假输出骗个分得了，老师应该不会查代码吧。说干就干…… What the FXXK! 假输出测试点击放大 \" 假输出测试 玩我呢，123456都试过了，就这就这？记得班群里有个同学过了一组数据，问他要了下他的代码，然后把他的输出分别写死123456，一样全都过不了。好吧，是后台有什么判断机制？ ","date":"2021-09-16","objectID":"/time-complexity/:2:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#探索二"},{"categories":["杂记随想"],"content":"探索三： 取不了巧，只好老老实实coding了，又做了两三种基于探索一的变种算法，样例数据都最多只能过两组，提交运行依然是没有一组通过。真的生气了，总觉得是后台有问题。喝了瓶薄荷味苏打水冷静了会儿后，决定还是从探索一的方法种的根本问题着手，即使用k组数据的问题，上面说了探索一中是基于两组数据的差值或比值分析，根本没完全利用到k组数据。既然要用k组数据，那我们先把一组数据单独拎出来研究好了。 当我们知道一个程序的运行规模n，和程序运行时间，那我们是不是能得到它的单位运行时间(不知道这个说法对不对，可以理解为当n为1的运行时间)。当然不能单纯的t / n，应该用t去除以n对应的复杂度函数才行，当每组数据按照某个复杂度函数除出来的单位时间最相近就是它对应的复杂度。 单位运行时间我就用uTime表示吧。 用示例中的数据举例： 第一组数据： n = 8, t = 0; 按O(n)求uTime： t / n; 按O(nlogn)求uTime： t / (n*log(n)); 按O(n^2)求uTime： t / (n*n); 按O(n^3)求uTime： t / (n*n*n); 按O(2^n)求uTime： t / (pow(2, n)); 按O(n!)求uTime： t / n!; 输入的k组数据都按照这个算法求得uTime，然后比较6种复杂度对应的k个uTime，当k个uTime最接近时候对应的复杂度算法便是该输入对应的复杂度。这里我用的方差去算的k个uTime的接近程度。当然这里的方差算法被我改动了，因为不同算法输入的规模n的数量级相差太大了，所以算方差的时候做了一个类似Normalization的方法。 方差计算代码如下： // 计算方差 double Variance(vector\u003cdouble\u003e \u0026uTimes) { double sum = std::accumulate(std::begin(uTimes), std::end(uTimes), 0.0); double mean = sum / uTimes.size(); //均值 double accum = 0.0; std::for_each (std::begin(uTimes), std::end(uTimes), [\u0026](const double d) { accum += (d/mean-1)*(d/mean-1); // Normalization，不然不能相互比较 }); return sqrt(accum/(uTimes.size())); } ","date":"2021-09-16","objectID":"/time-complexity/:3:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#探索三"},{"categories":["杂记随想"],"content":"AC 感觉探索三的思路没大问题了，但有一点，就是在n的数量级太大的时候2^n和n!根本没法算，所以示例数据前两个都是过了，第三个会崩。然后我又是先不管这个问题了，草草的把代码先写出来后就迫不及待的提交运行了。 ！！！又是一组都没通过！！！ 简直要爆粗口了，真的有理由怀疑后台有问题。反复的做实验，监视各个阶段的输出，觉得一切的很合理，但结果为什么就这么不合理呢。实在不知道怎么做了，就想着把O(2^n)和O(n!)的大规模输入问题先解决掉。这时想到了上一个作业，老师让我们编程输出这6个复杂度1s内能处理的最大规模N，O(2^n)和O(n!)在1s内能处理的问题规模都是很小的，都是两位数的数量级。于是我便想到一个trick，当n \u003e 30时，则不计算O(2^n)对应的uTime，同时把其对应的方差设成一个很大的值，例如10000这样。同理当n \u003e 30时,O(n!)对应的操作也做同样处理。 代码如下： int GetComplexity(map\u003cint, int\u003e \u0026nt) { vector\u003cdouble\u003e uTimes; // 记录不同复杂度对应的单位运行时间 vector\u003cdouble\u003e vars; // 记录6种复杂度对应uTime的方差 for (int i = 0; i \u003c 6; i++) { uTimes.clear(); bool flag = false; for (auto ntIter = nt.begin(); ntIter != nt.end(); ntIter++) { auto n = ntIter-\u003efirst; auto t = ntIter-\u003esecond; if ( i \u003e 3 \u0026\u0026 n \u003e 30) { flag = false; break; } uTimes.push_back(Fun[i](t, n)); } vars.push_back(!flag ? Variance(uTimes) : 10000); } auto min = min_element(begin(vars), end(vars)); return distance(begin(vars), min) + 1; // 返回最小方差的索引+1 } 为了方便实现探索一中的算法，所以用的std::map存储(n, t)，因为它能根据键值自动排序。后面也没有改过来，其实只用两个std::vector就可以了。 处理完后，我再提交，竟然就过了…就过了…过了…了…, 所以前面显示的未通过到底是什么? 是程序中断了吗? 还是什么神秘的控制机制。 喜大普奔点击放大 \" 喜大普奔 ","date":"2021-09-16","objectID":"/time-complexity/:4:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#ac"},{"categories":["杂记随想"],"content":"完整代码 /* * @Author: xxy * @Date: 2021-09-16 16:41:37 * @Description: 复杂度判断 */ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmap\u003e#include \u003ccmath\u003e#include \u003cnumeric\u003e #include \u003calgorithm\u003e using namespace std; // 求阶乘 int Fn(int n) { int f; if (n == 0 || n == 1) f = 1; else f = Fn(n - 1) * n; return f; } // 计算方差 double Variance(vector\u003cdouble\u003e \u0026uTimes) { double sum = accumulate(begin(uTimes), end(uTimes), 0.0); double mean = sum / uTimes.size(); //均值 double accum = 0.0; for_each (begin(uTimes), end(uTimes), [\u0026](const double d) { accum += (d/mean-1)*(d/mean-1); // Normalization，不然不能相互比较 }); return sqrt(accum/(uTimes.size())); } // 求单位运行时间 double f0 (double t, int n) { return t / n; } // O(n) double f1 (double t, int n) { return (t / (n * log2(n))); } // O(nlogn) double f2 (double t, int n) { return (t / pow(n, 2)); } // O(n^2) double f3 (double t, int n) { return (t / pow(n, 3)); } // O(n^3) double f4 (double t, int n) { return (t / pow(2, n)); } // O(2^n) double f5 (double t, int n) { return (t / Fn(n)); } // O(n!) // 定义函数数组 double (*Fun[])(double t, int n) { f0, f1, f2, f3, f4, f5 }; int GetComplexity(map\u003cint, int\u003e \u0026nt) { vector\u003cdouble\u003e uTimes; // 记录不同复杂度对应的单位运行时间 vector\u003cdouble\u003e vars; // 记录6种复杂度对应uTime的方差 for (int i = 0; i \u003c 6; i++) { uTimes.clear(); bool flag = false; for (auto ntIter = nt.begin(); ntIter != nt.end(); ntIter++) { auto n = ntIter-\u003efirst; auto t = ntIter-\u003esecond; if ( i \u003e 3 \u0026\u0026 n \u003e 30) { flag = false; break; } uTimes.push_back(Fun[i](t, n)); } vars.push_back(!flag ? Variance(uTimes) : 10000); } auto min = min_element(begin(vars), end(vars)); return distance(begin(vars), min) + 1; // 返回最小方差的索引+1 } int main() { int k; int tmp; map\u003cint, int\u003e ntMap; while (cin \u003e\u003e k \u0026\u0026 k) { vector\u003cint\u003e nVec; vector\u003cint\u003e tVec; ntMap.clear(); for (int i = 0; i \u003c k; i++) { cin \u003e\u003e tmp; nVec.push_back(tmp); } for (int i = 0; i \u003c k; i++) { cin \u003e\u003e tmp; tVec.push_back(tmp); } for (int i = 0; i \u003c k; i++) { ntMap[nVec[i]] = tVec[i]; } cout \u003c\u003c GetComplexity(ntMap) \u003c\u003c endl; } return 0; } ","date":"2021-09-16","objectID":"/time-complexity/:0:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#完整代码"},{"categories":["杂记随想"],"content":"小结 题目做完了，好像学到了点什么，又好像什么都没学到。总觉得这道题目但凡有一点意义也不至于一点意义也没有。 ","date":"2021-09-16","objectID":"/time-complexity/:0:0","series":null,"tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/#小结"},{"categories":["iOS"],"content":"手上有个很老的项目对应的苹果包需要在xcode上做些修改，苦于买不起Mac，只好出此下策 现在后悔去年买的那台2070显卡的笔记本了，就很后悔，为什么不买mac 好在家里的PC配置还可以，所以就想到用虚拟机来玩玩 ","date":"2021-06-10","objectID":"/vm-macos/:0:0","series":null,"tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/#"},{"categories":["iOS"],"content":"安装VM Player 虚拟机我选的是VMware Workstation Player, 注意后面这个player 个人用户用player就行了, 和Workstation相比, player免费, 体积小, 够用 直接到官网下载就行 ","date":"2021-06-10","objectID":"/vm-macos/:1:0","series":null,"tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/#安装vm-player"},{"categories":["iOS"],"content":"给VM打上MacOS补丁 距离我上一次用虚拟机装MacOS可能有八九年那么久了, 装完VM后才发现虚拟机的系统选项里已经没有Mac这个选项了, 网上查到需要通过补丁来解锁这个选项 这里使用Auto Unlocker解锁 软件直接放这了 链接: https://pan.baidu.com/s/1SS0VCgJo9Ey1LjjTh2aqkw 提取码: ajwo 软件转载于ypojie 下完解压直接unlock然后等待完成就行了 完成后创建虚拟机的时候选骚后安装操作系统, 下一步后就可以选择Apple Mac OS了, 版本默认就行, 没多大关系 创建虚拟机点击放大 \" 创建虚拟机 磁盘选项点击放大 \" 磁盘选项 磁盘大小这里有个坑, 建议80gb, 我这里选了60为后面安装XCode埋下了个大坑 最后虚拟机设置里把下载来的MacOS的IOS镜像放到虚拟机驱动器里就可以了 这是我用的镜像 链接: https://pan.baidu.com/s/18zXlfSU6OkaifQ-aHeQVtQ 提取码: 8ilm 配置完这些后启动虚拟就可以开始安装MacOS了 系统安装成功点击放大 \" 系统安装成功 ","date":"2021-06-10","objectID":"/vm-macos/:1:1","series":null,"tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/#给vm打上macos补丁"},{"categories":["iOS"],"content":"安装XCode 前面有说到磁盘大小会给安装XCode埋坑 因为我安装完系统后没有第一时间安装XCode, 我先装了些常用的软件, 反正装完一些软件后是还有40GB的磁盘空间, 然后我直接在app store上安装XCode, 下载完成后安装的过程中提示安装失败了, 我再点下载提示可用磁盘空间不足, 无法安装此产品 XCode下载的大小才11个多G, 用了网上的删除Time Machine的方法也没用, 因为我系统确实是只有40GB空闲 搞不懂为什么需要那么多空间安装, 于是想通过下载xip文件的方式来安装 下载地址是 https://developer.apple.com/download/all/?q=xcode 我下的是12.5版本 网页下载xcode点击放大 \" 网页下载xcode 下载完后点击安装还是报磁盘空间不足 无语… 果断关掉虚拟机, 打开虚拟机设置, 将磁盘扩展至80GB, 扩展需要花点时间 ","date":"2021-06-10","objectID":"/vm-macos/:2:0","series":null,"tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/#安装xcode"},{"categories":["iOS"],"content":"虚拟机磁盘空间扩展 扩展完成后并不是Mac里也会同步分区好, 需要手动给系统分区扩容, 因为虚拟机的硬盘变大后系统的分区表信息并不会变 Mac中打开终端输入 diskutil list 可以看到现在是磁盘信息, 比如图片中可以看到我的磁盘总空间是85.9GB但是Apple_APFS(disk0s2)只用了64.2GB, 还有21.5GB的free 系统扩容前点击放大 \" 系统扩容前 现在需要将disk0s2(每个人的数字可能不一样)扩容, 因为是APFS格式, 所以用resizeContainer命令 diskutil apfs resizeContainer disk0s2 85.6GB 命令执行成功后可以看到扩展的21.5GB也全都加到disk0s2中了 系统扩容后点击放大 \" 系统扩容后 这时候再安装XCode就ok了, xip解压出来是29.6GB左右, 加上xip本身是11.几GB, 所以应该至少要有42GB左右的空闲空间才够 安装成功点击放大 \" 安装成功 ","date":"2021-06-10","objectID":"/vm-macos/:2:1","series":null,"tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/#虚拟机磁盘空间扩展"},{"categories":["iOS"],"content":"小结 这是一段因为穷而导致的莫名奇妙的经历[doge] ","date":"2021-06-10","objectID":"/vm-macos/:3:0","series":null,"tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/#小结"},{"categories":["Linux"],"content":"前几天装了WSL，身为多年的伪Vim粉VS Code宇宙第一决定顺便把Vim给搞搞 本来是打算就用原生Vim然后堆plug的，但是既然已经折腾了，就不差这一下了。 ","date":"2021-02-18","objectID":"/neovim/:0:0","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#"},{"categories":["Linux"],"content":"安装Neovim 因为太久没玩过Ubuntu了，所以上来就是sudo apt install neovim，然后报Error，提示 Unable to locate package neovim 进Neovim官网看了下安装教程，在Ubuntu那一栏可以看到，从18.04开始可以通过PPA来安装了，照着官方教程一顿梭 sudo add-apt-repository ppa:neovim-ppa/stable sudo apt-get update sudo apt-get install neovim 老版本的Ubuntu可能需要先安装PPA sudo apt-get install software-properties-common 安装完后可以输入nvim 打开，当然可以修改下alias，通过vi打开nvim 这里我选择软连接的方式将vi连接到nvim，因为现在wsl系统里的vi和vim命令就是软连接文件，所以我想删掉现在的vi，然后重新软连接到nvim 先which vi 找到vi的目录， 比如我的系统中vi文件的目录是/usr/bin/ 再输入ls -il 可以看到vi是个连接文件，指向 /etc/alternatives/vi 然后这里我把两个软连接给删掉再建立新的软连接 sudo rm -rf /usr/bin/vi sudo rm -rf /usr/bin/vim sudo ln -s /usr/bin/nvim /usr/bin/vi sudo ln -s /usr/bin/nvim /usr/bin/vim 这时候再输入vi/vim就可以打开nvim了 Neovim点击放大 \" Neovim ","date":"2021-02-18","objectID":"/neovim/:1:0","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#安装neovim"},{"categories":["Linux"],"content":"安装SpaceVim SpaceVim是一个开源的模块化配置集合，可以通过它很方便的打造出适用于各种开发场景的IDE。 curl -sLf https://spacevim.org/cn/install.sh | bash 安装SpaceVim点击放大 \" 安装SpaceVim 字体安装报错点击放大 \" 字体安装报错 提示安装完成，打开vim却没有加载出SpaceVim，不知道哪里出现问题，往上翻也只看到几个字体安装的报错，感觉应该是和WSL环境的配置文件有关系，但还是先在网上找了那几个字体报错的解决方法 # 使mkfontscale和mkfontdir命令正常运行 sudo apt-get install ttf-mscorefonts-installer # 使fc-cache命令正常运行 sudo apt-get install fontconfig 然后再安装试试 结果还真是字体的问题，重装下就好了… SpaceVim点击放大 \" SpaceVim Normal模式下:SPUpdate 更新所有插件，:SPUpdate SpaceVim可以更新自身 更新所有插件点击放大 \" 更新所有插件 再次打开vim又 vimproc’s DLL报错，直接:VimProcInstall 或者make一下 cd ~/.SpaceVim/bundle/vimproc.vim/ make 有些icon显示不出来，只有个小方框，有可能是因为字体的问题 可以使用fc-list命令查看ubuntu中安装的字体 SpaceVim默认使用SourceCodePro Nerd Font Mono字体 安装Nerd Font wget -c https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/SourceCodePro.zip sudo unzip SourceCodePro -d /usr/share/fonts/SourceCodePro cd /usr/share/fonts/SourceCodePro sudo mkfontscale # 生成核心字体信息 sudo mkfontdir # 生成字体文件夹 sudo fc-cache -fv # 刷新系统字体缓存 如果使用终端的话需要修改终端的配置 比如我用的是Windows Terminal 在Windows下安装完SourceCodePro Nerd Font Mono字体后需要在Windows Terminal配置文件WSL配置下加上 \"fontFace\": \"SauceCodePro Nerd Font\" 注意第一个f小写，然后再重启终端就能看到图标都出来了 更新字体后点击放大 \" 更新字体后 ","date":"2021-02-18","objectID":"/neovim/:2:0","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#安装spacevim"},{"categories":["Linux"],"content":"一些简单的配置 ","date":"2021-02-18","objectID":"/neovim/:3:0","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#一些简单的配置"},{"categories":["Linux"],"content":"相对行号 看不习惯相对行号，在配置文件中取消 relativenumber = false ","date":"2021-02-18","objectID":"/neovim/:3:1","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#相对行号"},{"categories":["Linux"],"content":"主题 打开~/.SpaceVim.d/init.toml 主题选择 SpaceVim colorscheme = \"SpaceVim\" SpaceVim主题点击放大 \" SpaceVim主题 ","date":"2021-02-18","objectID":"/neovim/:3:2","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#主题"},{"categories":["Linux"],"content":"C++ 打开vim，空格 + f + v + d (一个个按)，快捷键打开配置文件，空格(space)为自定义快捷键的前缀，按下空格后可以看到所有的自定义快捷键 按照官方配置把需要的加上去就可以了 像clangd，clang这些如果需要的话要先装好才能配置成功，不然vim会报clangd is not executable 直接apt安装的clang貌似版本会有点低，所以建议用官方源 bash -c \"$(wget -O - https://apt.llvm.org/llvm.sh)\" 在/usr/bin 目录下找到你的clangd安装目录，比如我的是/usr/bin/clangd-11 再执行下面命令 sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-11 100 SpaceVim默认使用的补全插件是deoplete，愿意折腾的同学也可以改成YCM，注意兼容问题 最后在cpp文件中使用SPC + l + r就可以run代码了 修改编译命令可参考Custom Task ","date":"2021-02-18","objectID":"/neovim/:3:3","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#c"},{"categories":["Linux"],"content":"Python 官方文档 ","date":"2021-02-18","objectID":"/neovim/:3:4","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#python"},{"categories":["Linux"],"content":"小结 其实VS Code + Remote一套用起来才更虚服。 所以上面这些都是瞎折腾，桌面党还是继续老老实实用VS Code ","date":"2021-02-18","objectID":"/neovim/:4:0","series":null,"tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/#小结"},{"categories":null,"content":"最近需要在Linux下跑写些小程序，但是平时更多时候都离不开Windows打游戏。所以打算使用Win下的Linux子系统 ","date":"2021-02-09","objectID":"/wsl/:0:0","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#"},{"categories":null,"content":"启动WSL功能 首先在控制面板的打开或启动Windows程序中将Linux子系统功能勾选上，点确认后会提示重启计算机 控制面板-\u003e程序-\u003e启动或关闭Windows功能点击放大 \" 控制面板-程序-启动或关闭Windows功能 ","date":"2021-02-09","objectID":"/wsl/:1:0","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#启动wsl功能"},{"categories":null,"content":"安装Linux子系统 这里我选择了一个最方便直接的方法，在Windows商店下载安装，直接在商店搜索WSL，Ubuntu，或者Linux就能找到，比如我安装的是Ubuntu 20.04 安装Ubuntu子系统点击放大 \" 安装Ubuntu子系统 安装完成打开后输入用户名密码就可以使用了。 现在最新的WSL2是可以支持GPU的，所有一些跑Deep的小伙伴可以试试，可以在Windows命令行中输入如下命令查看当前的WSL版本，因为我不需要用到子系统的GPU，所有我没有升级到WSL2，有需要的可以自行找下教程 wsl --list -v 如果没有Windows商店没有满足你要求的Linux子系统，网上貌似也有教程教你运行各种不同的Linux子系统。 ","date":"2021-02-09","objectID":"/wsl/:2:0","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#安装linux子系统"},{"categories":null,"content":"文件共享 ","date":"2021-02-09","objectID":"/wsl/:3:0","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#文件共享"},{"categories":null,"content":"子系统访问Windows 在子系统的bash中cd /mnt可以看到Windows下的磁盘已经被挂载到子系统下，可以直接copy需要的文件到子系统中 ","date":"2021-02-09","objectID":"/wsl/:3:1","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#子系统访问windows"},{"categories":null,"content":"Windows访问子系统文件 子系统的磁盘空间对应Windows下的存储目录默认是在C:\\Users\\用户名\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc(这里改为自己的目录)\\LocalState\\rootfs ","date":"2021-02-09","objectID":"/wsl/:3:2","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#windows访问子系统文件"},{"categories":null,"content":"关于子系统桌面安装 这部分没内容，因为我并不推荐为Linux子系统安装桌面环境。 ","date":"2021-02-09","objectID":"/wsl/:4:0","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#关于子系统桌面安装"},{"categories":null,"content":"小结 后续使用过程中当然还会遇到许多坑，毕竟还有很多地方不成熟，比如使用ssh的时候可能会有端口占用问题，Windows访问子系统的权限问题等等。但是相对虚拟机来说，确实方便和实用许多，从系统功能完整性来说，个人认为是在虚拟机之下，Cygwin之上，毕竟Cygwin只是假装自己是个Linux，而WSL是实实在在的用Windows API实现Linux，对于用户层来说就是是实在在的Linux。 ","date":"2021-02-09","objectID":"/wsl/:5:0","series":null,"tags":null,"title":"Windows下运行Linux的正确姿势","uri":"/wsl/#小结"},{"categories":["人工智能"],"content":"在这个万物皆可CS的时代，程序猿如果不学点机器学习/深度学习知识，仿佛都有点跟不上潮流了 随着近几年人工智能的热潮，AI，AlphaGo，大数据，数据挖掘，机器学习这些词汇在互联网中随处可见。人脸识别，语音助手，美颜拍照，APP广告推送，甚至大数据杀熟这些技术的背后究竟是人性的泯灭，还是道德的沦丧… 咳咳… 回到正题，先来看看人工智能，机器学习，深度学习三者的关系 三者关系点击放大 \" 三者关系 ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#"},{"categories":["人工智能"],"content":"人工智能(AI) 一个笼统的概念，简单描述一门让机器好似有人类智慧的计算机学科。人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。 ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#人工智能ai"},{"categories":["人工智能"],"content":"机器学习(Machine Learning) 顾名思义是一种让计算机自己学习的算法。在智能应用开发的早期，许多系统都是使用大量的if-else结构来进行决策和处理数据的，比如希望判断邮件是否为垃圾邮件，可能需要先创建一个类似敏感词库的东西，然后判断邮件的内容是否包含这些关键词，if包含则为垃圾邮件，else不是垃圾邮件。这样的系统在某些领域确实是非常简单且高效的，尤其在一些系统所有的输入和输出都是能够被人们掌握的情况下。但是这种靠if-else的人为决策，明显很难对任务的变化进行自适应，且在开发系统时需对该系统将要处理的各种场景了如指掌。就像你很难用if-else来写一个人脸检测系统。 成功的机器学习算法是能够将决策过程自动化的那些算法，而这些决策过程是通过大量的数据输入(即已知的示例)中泛化得出的。 通常任何问题都可以用 $y=f(x)$ 模型或概率模型$P(Y|X)$ 表示，而机器学习的最终结果就是求出这个决策函数 $f(x)$ 或条件概率分布 $P(Y|X)$ ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#机器学习machine-learning"},{"categories":["人工智能"],"content":"基本概念 ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#基本概念"},{"categories":["人工智能"],"content":"样本数据 上面说到机器学习最终目的是求出 $y=f(x)$ 这个模型，样本数据便是一些已知的 $(x, y)$ 或者只有 $x$。其中 $x$ 叫做输入数据，$y$ 叫做输出数据（或者叫标签、标注）。$x$ 和 $y$可以是多维的可以包含多个特征。例如输入实例$x$的特征向量记作 $$ x= (x^{(1)}, x^{(2)}, x^{(3)}, \\ldots, x^{(i)}, \\ldots, x^{(n)})^T $$ $x^{(1)}$ 表示 $x$ 的第 $i$ 个特征。而 $x_i$表示多个输入中的第i个输入，即 $$ x_i = (x_{i}^{(1)}, x_{i}^{(2)}, x_{i}^{(3)}, \\ldots, x_{i}^{(n)}) $$ ","date":"2020-01-28","objectID":"/ml/:1:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#样本数据"},{"categories":["人工智能"],"content":"数据集 完整的数据集表示为 $T = \\lbrace(x_1, y_1), (x_2, y_2), (x_3, y_3), \\ldots, (x_n, y_n)\\rbrace$，并不是所有的数据都将用于模型训练，通常数据集会被分为三个部分：训练集、验证集、测试集 训练集：用于训练学习模型，通常比例不低于总数据量的50% 验证集：用于衡量训练过程中模型的好坏，通过不断迭代来优化模型 测试集：验证集智能用于监视和辅助模型训练，不能用来代表模型的好坏，哪怕验证的准确率是100%测试集也有可能是10%的准确率，这时的模型也是不能被接受的 ","date":"2020-01-28","objectID":"/ml/:2:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#数据集"},{"categories":["人工智能"],"content":"特征 特征是机器学习和模式识别领域一个比较特有的名词，在传统机器学习算法中，由于计算性能和参数的限制，所以输入的数据维数不能太高。我们手机随随便便一张照片就有几个MB的数据量，可能会有几百万个像素，这么高维的数据量我们是不能直接输入给学习机的，因此我们需要针对特别的应用提取相对应的特征向量，特征向量的作用主要有两个： 降低数据维度：通过提取特征向量，把原始数据的维度大大较低，简化模型的参数数量 提升模型性能：一个好的特征，可以提前把原始数据最关键的部分提取出来，因此可以提高学习机的性能 用于模型训练的每一个具体输入实例通常由特征向量表示，人工拆解特征的方法即所谓的特征工程，而深度学习算法自动将概念拆解成特征向量，免去的传统机器算法拆解特征这个步骤 ","date":"2020-01-28","objectID":"/ml/:3:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#特征"},{"categories":["人工智能"],"content":"机器学习基本分类 ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#机器学习基本分类"},{"categories":["人工智能"],"content":"监督学习 监督学习是指从带有标注的训练数据中学习预测模型的机器学习问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。其本质是学习输入到输出映射的统计规律。 通常分为学习和预测两个过程，学习系统利用给定的训练数据集通过学习（或者说训练）得到一个模型，预测系统对给定的测试样本集的输入得出相应的输出。 问题分类： 输入变量 $X$ 和输出变量 $Y$有不同的类型，可以是连续的，也可以是离散的。根据输入输出的不同类型，对预测任务给予了不同的名称： 分类问题：输出变量为有限个离散变量 回归问题：输入变量与输出变量均为连续 标注问题：输入变量与输出变量均为变量序列 ","date":"2020-01-28","objectID":"/ml/:1:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#监督学习"},{"categories":["人工智能"],"content":"非监督学习 非监督学习算法或者说无监督算法与监督学习算法的区别就在于，训练数据中只有输入是已知的，但是并没有为算法提供预期输出。需要算法自行总结数据中的规律，做出符合预期的判断。所以这类算法的理解和评估确实往往比较困难。 非监督学习算法可用于对已有数据的分析，也可以用于对未来数据的预测，与监督学习类似由学习系统和预测系统完成，其本质是学习数据中的统计规律或潜在结构。 非监督学习的两类算法： 聚类算法：根据数据的“相似性”将数据分为多类的过程，将数据集分成一个个的簇cluster（也可以理解为一组一组的形式） 降维算法：即在保证数据所具有的代表性特性或者分布的情况下，将高维数据转化为低维数据的过程（数据的可视化和精简数据） 非监督算法实例： 一家广告平台需要根据相似的人口学特征和购买习惯将美国人口分成不同的小组，以便广告客户可以通过有关联的广告接触到他们的目标客户 Airbnb 需要将自己的房屋清单分组成不同的社区，以便用户能更轻松地查阅这些清单 一个数据科学团队需要降低一个大型数据集的维度的数量，以便简化建模和降低文件大小 ","date":"2020-01-28","objectID":"/ml/:2:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#非监督学习"},{"categories":["人工智能"],"content":"强化学习 强化学习指智能系统在与环境互动中学习最优行为策略的机器学习问题，本质是学习最优的序贯决策。学习过程中，系统不断的试错，已达到学习最优策略的目的。 大名鼎鼎的AlphaGo背后就有这强化学习算法的支持。 ","date":"2020-01-28","objectID":"/ml/:3:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#强化学习"},{"categories":["人工智能"],"content":"半监督学习和自动学习 半监督学习：指利用标注数据和未标注数据学习，通常少量标注数据，大量未标注数据。因为标注数据的构建往往需要大量的人工，成本较高，未标注数据的收集则不需要太多成本。旨在利用未标注数据中的信息，辅助标注数据，进行监督学习，以较低的成本达到较好的学习效果 自动学习：指机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。通常的监督学习使用给定的标注数据往往是随机得到的，可以看做是”被动学习“，主动学习的目标是找出对学习最有帮助的实例让教师标注，以较小的标注代价，达到更好的学习效果 半监督学习和主动学习更接近监督学习 ","date":"2020-01-28","objectID":"/ml/:4:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#半监督学习和自动学习"},{"categories":["人工智能"],"content":"机器学习算法三要素 ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#机器学习算法三要素"},{"categories":["人工智能"],"content":"模型 模型是机器学习的最终结果，即上面所说的决策函数 $y=f(x)$ 或条件概率分布 $P(Y|X)$，它被用来预测特定问题下的某个输入对应的输出结果。而所有可能的决策函数或条件概率分布的集合便称为假设空间 ","date":"2020-01-28","objectID":"/ml/:1:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#模型"},{"categories":["人工智能"],"content":"策略 有了模型的假设空间，机器学习接着需要考虑按照什么样的准则学习或选择最优的模型。机器学习的目标便是从假设空间中选取最优模型。而最优的定义则由我们所选则的评价准则定义的，即我们选取的模型的策略。通常评价模型在某个样本点的好坏用损失函数 $L(Y, f(X))$ 表示，而对所有样本预测的平均好坏用风险函数 $R_{exp}(f) = E[L(Y, f(X))]$ 表示 ","date":"2020-01-28","objectID":"/ml/:2:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#策略"},{"categories":["人工智能"],"content":"算法 算法指学习模型的具体计算方法。机器学习基于训练数据集，根据学校策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型 这时，机器学习问题归结为最优化问题，机器学习的算法成为求解最优化问题的算法。例如，当已经知道问题模型属于权值向量参数未定的线性决策函数，那么确定一个经验风险最小化的权值向量的过程就是这次学习的算法 机器学习方法之间的不同，主要来自其模型、策略、算法的不同。确定了模型、策略、算法，机器学习的方法也就确定了。这就是将其称为机器学习方法三要素的原因 ","date":"2020-01-28","objectID":"/ml/:3:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#算法"},{"categories":["人工智能"],"content":"深度学习(Deep Learning) 讲深度学习前先讲讲神经网络，传统神经网络也是机器学习算法中的一员。而深度学习涉及训练多层神经网络，也称为深度神经网络。 未完待续… ","date":"2020-01-28","objectID":"/ml/:0:0","series":null,"tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/#深度学习deep-learning"}]