[{"categories":["杂记随想"],"content":"计算机程序设计艺术，第四卷第五册C，Dancing Links(舞蹈链算法) Dancing Links (舞蹈链)，是大名鼎鼎的 高德纳(Donald Knuth) 为快速实现他提出的X算法所提出的一种数据结构，所以也叫做 DLX算法，其目的是用于解决 精确覆盖问题。 覆盖问题 集合$S = \\lbrace1, 2, 3, 4, 5, 6, 7\\rbrace$，有其子集 $S_1 = \\lbrace3, 5\\rbrace$ $S_2 = \\lbrace1, 4, 7\\rbrace$ $S_3 = \\lbrace2, 3, 6\\rbrace$ $S_4 = \\lbrace1, 4, 6\\rbrace$ $S_5 = \\lbrace2, 7\\rbrace$ $S_6 = \\lbrace4, 5, 7\\rbrace$ 选择一些子集组成集合 $T$ ，使得 $T$ 中的包含的元素能覆盖集合 $S$ ，即 $S$ 中的所有元素都能在 $T$ 中找到包含它的子集（$\\forall x \\in S \\rightarrow \\forall x \\in T$）。 重复覆盖： 集合 $S$ 中的任意成员 $x$ 允许同时属于两个以上的子集，例如 $T=\\lbrace S_1, S_2, S_3\\rbrace$ 重复覆盖S。 精确覆盖： 集合 $S$ 中的任意成员 $x$ 属于且只属于 $T$ 中的一个子集，例如 $T=\\lbrace S_1, S_4, S_5\\rbrace$ 精确覆盖S。 用矩阵表示上述问题： 算法步骤如下： 如果矩阵 $A$ 为空且所有列都被选中，则当前局部解即为问题的一个解，返回成功；否则继续。 根据一定方法选择第 $c$ 列。如果某一列中没有1，则返回失败，并去除当前局部解中最新加入的行。 选择第 $r$ 行，使得 $A_{(r,c)} = 1$（该步是不确定的）。 将第 $r$ 行加入当前局部解中。 对于满足 $A_{(r,j)} = 1$ 的每一列 $j$，从矩阵 $A$ 中删除所有满足$A_{(i,j)} = 1$的行，最后再删除第 $j$ 列。 对所得比 $A$ 小的新矩阵递归地执行此算法。 $$ %S = % \\begin{pmatrix} % 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0\\\\ % 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1\\\\ % 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ % 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0\\\\ % 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1\\\\ % 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ % \\end{pmatrix} $$ 即选出矩阵的若干行，使得其中的1在所有列中出现且仅出现一次 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{7}\\\\ \\hline \\mathbf\\textcolor{blue}{S_1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0}\\\\ \\hline \\mathbf{S_2} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_3} \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf\\textcolor{blue}{S_4} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0}\\\\ \\hline \\mathbf\\textcolor{blue}{S_5} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{1}\\\\ \\hline \\mathbf{S_6} \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 蓝色标记的三行($S_1, S_4, S_5$)，便是精确覆盖问题的解 $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{7}\\\\ \\hline \\mathbf\\textcolor{blue}{S_1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0}\\\\ \\mathbf\\textcolor{blue}{S_4} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0}\\\\ \\mathbf\\textcolor{blue}{S_5} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\textcolor{blue}{0} \u0026 \\fcolorbox{red}{aqua}{1}\\\\ \\hline \\end{array} $$ 肉眼很容易一眼看出答案，但是计算机需要具体的算法步骤才行。下面看看 X算法 是如何求解的。 X算法（DFS回溯） 初始状态： $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf{7}\\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0\\\\ \\hline \\mathbf{S_2} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_3} \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_4} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_5} \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1\\\\ \\hline \\mathbf{S_6} \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 1\\\\ \\hline \\end{array} $$ 高德纳建议每次选取 1 最少的列 X算法的执行步骤如下： 第一步： 选取1最少的列，此时第1，2，3，5，6列1的个数都是2，选择第1列。第1列中 $S_2$ 和 $S_4$均为1，选择 $S_2$ 加入当前解。（$T=\\lbrace S_2\\rbrace$） $$ \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \u0026 \\mathbf\\textcolor{blue}{1} \u0026 \\mathbf{2} \u0026 \\mathbf{3} \u0026 \\mathbf\\textcolor{blue}{4} \u0026 \\mathbf{5} \u0026 \\mathbf{6} \u0026 \\mathbf\\textcolor{blue}{7}\\\\ \\hline \\mathbf{S_1} \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0 \u0026 0\\\\ \\hline \\mathbf\\textcolor{blue}{S_2} \u0026 \\textcolor{blue}{1} \u0026 0 \u0026 0 \u0026 \\textcolor{blue}{1} \u0026 0 \u0026 0 \u0026 \\textcolor{blue}{1}\\\\ \\hline \\mathbf{S_3} \u0026 0 \u0026 1 \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_4} \u0026 1 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 1 \u0026 0\\\\ \\hline \\mathbf{S_5} \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026","date":"2021-09-22","objectID":"/dancinglinks/:0:0","tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/"},{"categories":["杂记随想"],"content":"数据结构定义 Dancing Links使用的是十字交叉双向循坏列表，即每个结点除了 Left, Right 指针外还存在 Up, Down 指针。同时还有一个指针指向所在的列结点。还需要一个Head结点，当Head-\u003eRight == Head 为 true 时，求解结束。（Head 结点只有 Left, Right 两个有效指针） class DLNode { public: DLNode * Left; // 左结点 DLNode *Right; // 右结点 DLNode *Up; // 上结点 DLNode *Down; // 下结点 DLNode *Col; // 所属列结点 int row; // 行号 int nums; // 该列存在的结点个数（当结点为列结点时有效，否则为-1） DLNode(DLNode *Col, int n, int s = -1): Left(this), Right(this), Up(this), Down(this), Col(Col), row(n), nums(s){ if (Col) Col-\u003eAdd2Colume(this); }; ~DLNode() {}; void Add2Row(DLNode *node); // 添加结点到该行末尾 void Add2Colume(DLNode *node); // 添加结点到该列尾 void RemoveCol(); // 移除该结点所在的列 void RecoverCol(); // 还原列 void Remove(); // 移除该结点关联的行和列 }; class DancingLinks { public: DancingLinks(int s[M][N]); ~DancingLinks(); DLNode *Head; // 头结点 std::vector\u003cDLNode *\u003e Cols; // 列向量 std::vector\u003cDLNode *\u003e Ans; // 保存结果 bool DLX(); // DLX算法求解 void ShowResult(); // 输出结果 }; 根据前面的精确覆盖问题构建Dancing Links结构。 Dancing Links结构图点击放大 \" Dancing Links结构图 ","date":"2021-09-22","objectID":"/dancinglinks/:1:0","tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/"},{"categories":["杂记随想"],"content":"DLX算法求解过程 首先判断 Head-\u003eRight == Head，若为真，求解完成，输出结果。否则算法继续执行。执行过程与前面所述的X算法类似，因此不再赘述。 代码如下： // 初始化Dancing Links DancingLinks::DancingLinks(int s[M][N]) { Head = new DLNode(nullptr, 0); // N列，创建N个列结点 for (int i = 0; i \u003c N; i++) { auto t = new DLNode(nullptr, 0, 0); Head-\u003eAdd2Row(t); Cols.push_back(t); } for (int r = 0; r \u003c M; r++) { bool flag = false; DLNode *node = nullptr; for (int c = 0; c \u003c N; c++) { // 创建结点 if (s[r][c]) { // 该行的第一个结点 if (!flag) { node = new DLNode(Cols[c], r+1); flag = true; } node-\u003eAdd2Row(new DLNode(Cols[c], r+1)); } } } // 移除初始为空的列 for (auto col = Head-\u003eRight; col != Head; col = col-\u003eRight) { if (!col-\u003enums) col-\u003eRemoveCol(); } } // DLX算法 bool DancingLinks::DLX() { if (Head-\u003eRight == Head) { ShowResult(); return true; } DLNode *col = nullptr; int min = INT_MIN; // 找到列元素最少的列 for (auto c = Head-\u003eRight; c != Head; c = c-\u003eRight) { if (min \u003e c-\u003enums) { col = c; min = c-\u003enums; } } col-\u003eRemoveCol(); for (auto node = col-\u003eDown; node != col; node = node-\u003eDown) { Ans.push_back(node); for (auto rnode = node-\u003eRight; rnode != node; rnode = rnode-\u003eRight) { rnode-\u003eCol-\u003eRemoveCol(); } if (DLX()) return true; for (auto lnode = node-\u003eLeft; lnode != node; lnode = lnode-\u003eLeft) { lnode-\u003eCol-\u003eRecoverCol(); } Ans.pop_back(); } col-\u003eRecoverCol(); } 程序完整代码： https://github.com/xxy-im/DancingLinks 参考文章 https://en.wikipedia.org/wiki/Dancing_Links https://www.cnblogs.com/grenet/p/3163550.html ","date":"2021-09-22","objectID":"/dancinglinks/:2:0","tags":["数据结构","算法"],"title":"Dancing Links (DLX 算法)学习笔记","uri":"/dancinglinks/"},{"categories":["杂记随想"],"content":"这是一篇关于一道算法课课后作业解题过程的一些思考 最近开始上算法设计与分析课，课后老师布置了一道关于时间复杂度的编程题。题目应该是老师自己编的。说实话，时间复杂度这种东西以前从来没有重视过，只停留根据代码判断程序时间复杂度的阶段。所以一开始也觉得做这种题目真是浪费时间(当然现在好像也觉得这题目没什么卵用)。 题目如下： 为了简单，只考虑6种算法的时间复杂度类型，分别为O(n)，O(nlogn)，O(n^2)，O(n^3)，O(2^n)和O(n!)。现有大量运行结果，请你根据运行结果判断复杂度类型。 输入： 第一行：一个整数k，表明有k对运行数据（n, t），n为运行规模，t为运行时间，都是整数。 第二行：k个整数，为运行规模，整数（\u003c1000001），每个数据之间有一个空格 第三行：k个整数，为运行时间，整数（\u003c100000），每个数据之间有一个空格 重复这三行，直至k=0。 输出： 每个例子输出一个整数（1-6之间），占一行，1,2,3,4,5,6分别代表复杂度类型O(n)，O(nlogn)，O(n^2)，O(n^3)，O(2^n)和O(n!)。最后一个例子也有回车 输入实例: 4 8 10 11 9 0 375 4218 31 6 17 20 24 19 22 25 16 110 1703 47 406 3468 5 359999 431998 518397 300000 746491 31 47 47 31 78 0 输出示例: 6 5 2 思考 ","date":"2021-09-16","objectID":"/time-complexity/:0:0","tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/"},{"categories":["杂记随想"],"content":"探索一： 第一眼看到题目的时候一边想着这什么鬼一边又觉得这题目还挺新颖的。首先想到的是从运行规模之间的差值和运行时间的比值这方面下手。感觉这也是很多同学一开始的思路，然后做着做着发现这样的做法好像不需要用到k组数据呀，不是两组就行了吗。不管了，先做下去吧。代码写完，用实例测一遍，emmmmmm… 没过，不管先去页面上run一次。好家伙，一组数据都没通过。 提交运行点击放大 \" 提交运行 ","date":"2021-09-16","objectID":"/time-complexity/:1:0","tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/"},{"categories":["杂记随想"],"content":"探索二： 我真的太菜了，实在不行我做下假输出骗个分得了，老师应该不会查代码吧。说干就干…… What the FXXK! 假输出测试点击放大 \" 假输出测试 玩我呢，123456都试过了，就这就这？记得班群里有个同学过了一组数据，问他要了下他的代码，然后把他的输出分别写死123456，一样全都过不了。好吧，是后台有什么判断机制？ ","date":"2021-09-16","objectID":"/time-complexity/:2:0","tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/"},{"categories":["杂记随想"],"content":"探索三： 取不了巧，只好老老实实coding了，又做了两三种基于探索一的变种算法，样例数据都最多只能过两组，提交运行依然是没有一组通过。真的生气了，总觉得是后台有问题。喝了瓶薄荷味苏打水冷静了会儿后，决定还是从探索一的方法种的根本问题着手，即使用k组数据的问题，上面说了探索一中是基于两组数据的差值或比值分析，根本没完全利用到k组数据。既然要用k组数据，那我们先把一组数据单独拎出来研究好了。 当我们知道一个程序的运行规模n，和程序运行时间，那我们是不是能得到它的单位运行时间(不知道这个说法对不对，可以理解为当n为1的运行时间)。当然不能单纯的t / n，应该用t去除以n对应的复杂度函数才行，当每组数据按照某个复杂度函数除出来的单位时间最相近就是它对应的复杂度。 单位运行时间我就用uTime表示吧。 用示例中的数据举例： 第一组数据： n = 8, t = 0; 按O(n)求uTime： t / n; 按O(nlogn)求uTime： t / (n*log(n)); 按O(n^2)求uTime： t / (n*n); 按O(n^3)求uTime： t / (n*n*n); 按O(2^n)求uTime： t / (pow(2, n)); 按O(n!)求uTime： t / n!; 输入的k组数据都按照这个算法求得uTime，然后比较6种复杂度对应的k个uTime，当k个uTime最接近时候对应的复杂度算法便是该输入对应的复杂度。这里我用的方差去算的k个uTime的接近程度。当然这里的方差算法被我改动了，因为不同算法输入的规模n的数量级相差太大了，所以算方差的时候做了一个类似Normalization的方法。 方差计算代码如下： // 计算方差 double Variance(vector\u003cdouble\u003e \u0026uTimes) { double sum = std::accumulate(std::begin(uTimes), std::end(uTimes), 0.0); double mean = sum / uTimes.size(); //均值 double accum = 0.0; std::for_each (std::begin(uTimes), std::end(uTimes), [\u0026](const double d) { accum += (d/mean-1)*(d/mean-1); // Normalization，不然不能相互比较 }); return sqrt(accum/(uTimes.size())); } ","date":"2021-09-16","objectID":"/time-complexity/:3:0","tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/"},{"categories":["杂记随想"],"content":"AC 感觉探索三的思路没大问题了，但有一点，就是在n的数量级太大的时候2^n和n!根本没法算，所以示例数据前两个都是过了，第三个会崩。然后我又是先不管这个问题了，草草的把代码先写出来后就迫不及待的提交运行了。 ！！！又是一组都没通过！！！ 简直要爆粗口了，真的有理由怀疑后台有问题。反复的做实验，监视各个阶段的输出，觉得一切的很合理，但结果为什么就这么不合理呢。实在不知道怎么做了，就想着把O(2^n)和O(n!)的大规模输入问题先解决掉。这时想到了上一个作业，老师让我们编程输出这6个复杂度1s内能处理的最大规模N，O(2^n)和O(n!)在1s内能处理的问题规模都是很小的，都是两位数的数量级。于是我便想到一个trick，当n \u003e 30时，则不计算O(2^n)对应的uTime，同时把其对应的方差设成一个很大的值，例如10000这样。同理当n \u003e 30时,O(n!)对应的操作也做同样处理。 代码如下： int GetComplexity(map\u003cint, int\u003e \u0026nt) { vector\u003cdouble\u003e uTimes; // 记录不同复杂度对应的单位运行时间 vector\u003cdouble\u003e vars; // 记录6种复杂度对应uTime的方差 for (int i = 0; i \u003c 6; i++) { uTimes.clear(); bool flag = false; for (auto ntIter = nt.begin(); ntIter != nt.end(); ntIter++) { auto n = ntIter-\u003efirst; auto t = ntIter-\u003esecond; if ( i \u003e 3 \u0026\u0026 n \u003e 30) { flag = false; break; } uTimes.push_back(Fun[i](t, n)); } vars.push_back(!flag ? Variance(uTimes) : 10000); } auto min = min_element(begin(vars), end(vars)); return distance(begin(vars), min) + 1; // 返回最小方差的索引+1 } 为了方便实现探索一中的算法，所以用的std::map存储(n, t)，因为它能根据键值自动排序。后面也没有改过来，其实只用两个std::vector就可以了。 处理完后，我再提交，竟然就过了…就过了…过了…了…, 所以前面显示的未通过到底是什么? 是程序中断了吗? 还是什么神秘的控制机制。 喜大普奔点击放大 \" 喜大普奔 完整代码 /* * @Author: xxy * @Date: 2021-09-16 16:41:37 * @Description: 复杂度判断 */ #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cmap\u003e#include \u003ccmath\u003e#include \u003cnumeric\u003e #include \u003calgorithm\u003e using namespace std; // 求阶乘 int Fn(int n) { int f; if (n == 0 || n == 1) f = 1; else f = Fn(n - 1) * n; return f; } // 计算方差 double Variance(vector\u003cdouble\u003e \u0026uTimes) { double sum = accumulate(begin(uTimes), end(uTimes), 0.0); double mean = sum / uTimes.size(); //均值 double accum = 0.0; for_each (begin(uTimes), end(uTimes), [\u0026](const double d) { accum += (d/mean-1)*(d/mean-1); // Normalization，不然不能相互比较 }); return sqrt(accum/(uTimes.size())); } // 求单位运行时间 double f0 (double t, int n) { return t / n; } // O(n) double f1 (double t, int n) { return (t / (n * log2(n))); } // O(nlogn) double f2 (double t, int n) { return (t / pow(n, 2)); } // O(n^2) double f3 (double t, int n) { return (t / pow(n, 3)); } // O(n^3) double f4 (double t, int n) { return (t / pow(2, n)); } // O(2^n) double f5 (double t, int n) { return (t / Fn(n)); } // O(n!) // 定义函数数组 double (*Fun[])(double t, int n) { f0, f1, f2, f3, f4, f5 }; int GetComplexity(map\u003cint, int\u003e \u0026nt) { vector\u003cdouble\u003e uTimes; // 记录不同复杂度对应的单位运行时间 vector\u003cdouble\u003e vars; // 记录6种复杂度对应uTime的方差 for (int i = 0; i \u003c 6; i++) { uTimes.clear(); bool flag = false; for (auto ntIter = nt.begin(); ntIter != nt.end(); ntIter++) { auto n = ntIter-\u003efirst; auto t = ntIter-\u003esecond; if ( i \u003e 3 \u0026\u0026 n \u003e 30) { flag = false; break; } uTimes.push_back(Fun[i](t, n)); } vars.push_back(!flag ? Variance(uTimes) : 10000); } auto min = min_element(begin(vars), end(vars)); return distance(begin(vars), min) + 1; // 返回最小方差的索引+1 } int main() { int k; int tmp; map\u003cint, int\u003e ntMap; while (cin \u003e\u003e k \u0026\u0026 k) { vector\u003cint\u003e nVec; vector\u003cint\u003e tVec; ntMap.clear(); for (int i = 0; i \u003c k; i++) { cin \u003e\u003e tmp; nVec.push_back(tmp); } for (int i = 0; i \u003c k; i++) { cin \u003e\u003e tmp; tVec.push_back(tmp); } for (int i = 0; i \u003c k; i++) { ntMap[nVec[i]] = tVec[i]; } cout \u003c\u003c GetComplexity(ntMap) \u003c\u003c endl; } return 0; } 小结 题目做完了，好像学到了点什么，又好像什么都没学到。总觉得这道题目但凡有一点意义也不至于一点意义也没有。 ","date":"2021-09-16","objectID":"/time-complexity/:4:0","tags":["算法","解题"],"title":"关于复杂度类型判断的some思考","uri":"/time-complexity/"},{"categories":["iOS"],"content":"手上有个很老的项目对应的苹果包需要在xcode上做些修改，苦于买不起Mac，只好出此下策 现在后悔去年买的那台2070显卡的笔记本了，就很后悔，为什么不买mac 好在家里的PC配置还可以，所以就想到用虚拟机来玩玩 ","date":"2021-06-10","objectID":"/vm-macos/:0:0","tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/"},{"categories":["iOS"],"content":"安装VM Player 虚拟机我选的是VMware Workstation Player, 注意后面这个player 个人用户用player就行了, 和Workstation相比, player免费, 体积小, 够用 直接到官网下载就行 ","date":"2021-06-10","objectID":"/vm-macos/:1:0","tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/"},{"categories":["iOS"],"content":"给VM打上MacOS补丁 距离我上一次用虚拟机装MacOS可能有八九年那么久了, 装完VM后才发现虚拟机的系统选项里已经没有Mac这个选项了, 网上查到需要通过补丁来解锁这个选项 这里使用Auto Unlocker解锁 软件直接放这了 链接: https://pan.baidu.com/s/1SS0VCgJo9Ey1LjjTh2aqkw 提取码: ajwo 软件转载于ypojie 下完解压直接unlock然后等待完成就行了 完成后创建虚拟机的时候选骚后安装操作系统, 下一步后就可以选择Apple Mac OS了, 版本默认就行, 没多大关系 创建虚拟机点击放大 \" 创建虚拟机 磁盘选项点击放大 \" 磁盘选项 磁盘大小这里有个坑, 建议80gb, 我这里选了60为后面安装XCode埋下了个大坑 最后虚拟机设置里把下载来的MacOS的IOS镜像放到虚拟机驱动器里就可以了 这是我用的镜像 链接: https://pan.baidu.com/s/18zXlfSU6OkaifQ-aHeQVtQ 提取码: 8ilm 配置完这些后启动虚拟就可以开始安装MacOS了 系统安装成功点击放大 \" 系统安装成功 ","date":"2021-06-10","objectID":"/vm-macos/:1:1","tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/"},{"categories":["iOS"],"content":"安装XCode 前面有说到磁盘大小会给安装XCode埋坑 因为我安装完系统后没有第一时间安装XCode, 我先装了些常用的软件, 反正装完一些软件后是还有40GB的磁盘空间, 然后我直接在app store上安装XCode, 下载完成后安装的过程中提示安装失败了, 我再点下载提示可用磁盘空间不足, 无法安装此产品 XCode下载的大小才11个多G, 用了网上的删除Time Machine的方法也没用, 因为我系统确实是只有40GB空闲 搞不懂为什么需要那么多空间安装, 于是想通过下载xip文件的方式来安装 下载地址是 https://developer.apple.com/download/all/?q=xcode 我下的是12.5版本 网页下载xcode点击放大 \" 网页下载xcode 下载完后点击安装还是报磁盘空间不足 无语… 果断关掉虚拟机, 打开虚拟机设置, 将磁盘扩展至80GB, 扩展需要花点时间 ","date":"2021-06-10","objectID":"/vm-macos/:2:0","tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/"},{"categories":["iOS"],"content":"虚拟机磁盘空间扩展 扩展完成后并不是Mac里也会同步分区好, 需要手动给系统分区扩容, 因为虚拟机的硬盘变大后系统的分区表信息并不会变 Mac中打开终端输入 diskutil list 可以看到现在是磁盘信息, 比如图片中可以看到我的磁盘总空间是85.9GB但是Apple_APFS(disk0s2)只用了64.2GB, 还有21.5GB的free 系统扩容前点击放大 \" 系统扩容前 现在需要将disk0s2(每个人的数字可能不一样)扩容, 因为是APFS格式, 所以用resizeContainer命令 diskutil apfs resizeContainer disk0s2 85.6GB 命令执行成功后可以看到扩展的21.5GB也全都加到disk0s2中了 系统扩容后点击放大 \" 系统扩容后 这时候再安装XCode就ok了, xip解压出来是29.6GB左右, 加上xip本身是11.几GB, 所以应该至少要有42GB左右的空闲空间才够 安装成功点击放大 \" 安装成功 ","date":"2021-06-10","objectID":"/vm-macos/:2:1","tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/"},{"categories":["iOS"],"content":"小结 这是一段因为穷而导致的莫名奇妙的经历[doge] ","date":"2021-06-10","objectID":"/vm-macos/:3:0","tags":["虚拟机","iOS","MacOS","XCode"],"title":"虚拟机下的iOS开发(MacOS + XCode)","uri":"/vm-macos/"},{"categories":["Linux"],"content":"前几天装了WSL，身为多年的伪Vim粉VS Code宇宙第一决定顺便把Vim给搞搞 本来是打算就用原生Vim然后堆plug的，但是既然已经折腾了，就不差这一下了。 ","date":"2021-02-18","objectID":"/neovim/:0:0","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"安装Neovim 因为太久没玩过Ubuntu了，所以上来就是sudo apt install neovim，然后报Error，提示 Unable to locate package neovim 进Neovim官网看了下安装教程，在Ubuntu那一栏可以看到，从18.04开始可以通过PPA来安装了，照着官方教程一顿梭 sudo add-apt-repository ppa:neovim-ppa/stable sudo apt-get update sudo apt-get install neovim 老版本的Ubuntu可能需要先安装PPA sudo apt-get install software-properties-common 安装完后可以输入nvim 打开，当然可以修改下alias，通过vi打开nvim 这里我选择软连接的方式将vi连接到nvim，因为现在wsl系统里的vi和vim命令就是软连接文件，所以我想删掉现在的vi，然后重新软连接到nvim 先which vi 找到vi的目录， 比如我的系统中vi文件的目录是/usr/bin/ 再输入ls -il 可以看到vi是个连接文件，指向 /etc/alternatives/vi 然后这里我把两个软连接给删掉再建立新的软连接 sudo rm -rf /usr/bin/vi sudo rm -rf /usr/bin/vim sudo ln -s /usr/bin/nvim /usr/bin/vi sudo ln -s /usr/bin/nvim /usr/bin/vim 这时候再输入vi/vim就可以打开nvim了 Neovim点击放大 \" Neovim ","date":"2021-02-18","objectID":"/neovim/:1:0","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"安装SpaceVim SpaceVim是一个开源的模块化配置集合，可以通过它很方便的打造出适用于各种开发场景的IDE。 curl -sLf https://spacevim.org/cn/install.sh | bash 安装SpaceVim点击放大 \" 安装SpaceVim 字体安装报错点击放大 \" 字体安装报错 提示安装完成，打开vim却没有加载出SpaceVim，不知道哪里出现问题，往上翻也只看到几个字体安装的报错，感觉应该是和WSL环境的配置文件有关系，但还是先在网上找了那几个字体报错的解决方法 # 使mkfontscale和mkfontdir命令正常运行 sudo apt-get install ttf-mscorefonts-installer # 使fc-cache命令正常运行 sudo apt-get install fontconfig 然后再安装试试 结果还真是字体的问题，重装下就好了… SpaceVim点击放大 \" SpaceVim Normal模式下:SPUpdate 更新所有插件，:SPUpdate SpaceVim可以更新自身 更新所有插件点击放大 \" 更新所有插件 再次打开vim又 vimproc’s DLL报错，直接:VimProcInstall 或者make一下 cd ~/.SpaceVim/bundle/vimproc.vim/ make 有些icon显示不出来，只有个小方框，有可能是因为字体的问题 可以使用fc-list命令查看ubuntu中安装的字体 SpaceVim默认使用SourceCodePro Nerd Font Mono字体 安装Nerd Font wget -c https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/SourceCodePro.zip sudo unzip SourceCodePro -d /usr/share/fonts/SourceCodePro cd /usr/share/fonts/SourceCodePro sudo mkfontscale # 生成核心字体信息 sudo mkfontdir # 生成字体文件夹 sudo fc-cache -fv # 刷新系统字体缓存 如果使用终端的话需要修改终端的配置 比如我用的是Windows Terminal 在Windows下安装完SourceCodePro Nerd Font Mono字体后需要在Windows Terminal配置文件WSL配置下加上 \"fontFace\": \"SauceCodePro Nerd Font\" 注意第一个f小写，然后再重启终端就能看到图标都出来了 更新字体后点击放大 \" 更新字体后 ","date":"2021-02-18","objectID":"/neovim/:2:0","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"一些简单的配置 ","date":"2021-02-18","objectID":"/neovim/:3:0","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"相对行号 看不习惯相对行号，在配置文件中取消 relativenumber = false ","date":"2021-02-18","objectID":"/neovim/:3:1","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"主题 打开~/.SpaceVim.d/init.toml 主题选择 SpaceVim colorscheme = \"SpaceVim\" SpaceVim主题点击放大 \" SpaceVim主题 ","date":"2021-02-18","objectID":"/neovim/:3:2","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"C++ 打开vim，空格 + f + v + d (一个个按)，快捷键打开配置文件，空格(space)为自定义快捷键的前缀，按下空格后可以看到所有的自定义快捷键 按照官方配置把需要的加上去就可以了 像clangd，clang这些如果需要的话要先装好才能配置成功，不然vim会报clangd is not executable 直接apt安装的clang貌似版本会有点低，所以建议用官方源 bash -c \"$(wget -O - https://apt.llvm.org/llvm.sh)\" 在/usr/bin 目录下找到你的clangd安装目录，比如我的是/usr/bin/clangd-11 再执行下面命令 sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-11 100 SpaceVim默认使用的补全插件是deoplete，愿意折腾的同学也可以改成YCM，注意兼容问题 最后在cpp文件中使用SPC + l + r就可以run代码了 修改编译命令可参考Custom Task ","date":"2021-02-18","objectID":"/neovim/:3:3","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"Python 官方文档 ","date":"2021-02-18","objectID":"/neovim/:3:4","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"小结 其实VS Code + Remote一套用起来才更虚服。 所以上面这些都是瞎折腾，桌面党还是继续老老实实用VS Code ","date":"2021-02-18","objectID":"/neovim/:4:0","tags":["Vim","Linux"],"title":"Ubuntu下安装Neovim+SpaceVim","uri":"/neovim/"},{"categories":["Linux"],"content":"最近需要在Linux下跑写些小程序，但是平时更多时候都离不开Windows打游戏。所以打算使用Win下的Linux子系统 ","date":"2021-02-09","objectID":"/wsl/:0:0","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"启动WSL功能 首先在控制面板的打开或启动Windows程序中将Linux子系统功能勾选上，点确认后会提示重启计算机 控制面板-\u003e程序-\u003e启动或关闭Windows功能点击放大 \" 控制面板-程序-启动或关闭Windows功能 ","date":"2021-02-09","objectID":"/wsl/:1:0","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"安装Linux子系统 这里我选择了一个最方便直接的方法，在Windows商店下载安装，直接在商店搜索WSL，Ubuntu，或者Linux就能找到，比如我安装的是Ubuntu 20.04 安装Ubuntu子系统点击放大 \" 安装Ubuntu子系统 安装完成打开后输入用户名密码就可以使用了。 现在最新的WSL2是可以支持GPU的，所有一些跑Deep的小伙伴可以试试，可以在Windows命令行中输入如下命令查看当前的WSL版本，因为我不需要用到子系统的GPU，所有我没有升级到WSL2，有需要的可以自行找下教程 wsl --list -v 如果没有Windows商店没有满足你要求的Linux子系统，网上貌似也有教程教你运行各种不同的Linux子系统。 ","date":"2021-02-09","objectID":"/wsl/:2:0","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"文件共享 ","date":"2021-02-09","objectID":"/wsl/:3:0","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"子系统访问Windows 在子系统的bash中cd /mnt可以看到Windows下的磁盘已经被挂载到子系统下，可以直接copy需要的文件到子系统中 ","date":"2021-02-09","objectID":"/wsl/:3:1","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"Windows访问子系统文件 子系统的磁盘空间对应Windows下的存储目录默认是在C:\\Users\\用户名\\AppData\\Local\\Packages\\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc(这里改为自己的目录)\\LocalState\\rootfs ","date":"2021-02-09","objectID":"/wsl/:3:2","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"关于子系统桌面安装 这部分没内容，因为我并不推荐为Linux子系统安装桌面环境。 ","date":"2021-02-09","objectID":"/wsl/:4:0","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["Linux"],"content":"小结 后续使用过程中当然还会遇到许多坑，毕竟还有很多地方不成熟，比如使用ssh的时候可能会有端口占用问题，Windows访问子系统的权限问题等等。但是相对虚拟机来说，确实方便和实用许多，从系统功能完整性来说，个人认为是在虚拟机之下，Cygwin之上，毕竟Cygwin只是假装自己是个Linux，而WSL是实实在在的用Windows API实现Linux，对于用户层来说就是是实在在的Linux。 ","date":"2021-02-09","objectID":"/wsl/:5:0","tags":["WSL","Linux"],"title":"Windows下运行Linux的正确姿势","uri":"/wsl/"},{"categories":["人工智能"],"content":"在这个万物皆可CS的时代，程序猿如果不学点机器学习/深度学习知识，仿佛都有点跟不上潮流了 随着近几年人工智能的热潮，AI，AlphaGo，大数据，数据挖掘，机器学习这些词汇在互联网中随处可见。人脸识别，语音助手，美颜拍照，APP广告推送，甚至大数据杀熟这些技术的背后究竟是人性的泯灭，还是道德的沦丧… 咳咳… 回到正题，先来看看人工智能，机器学习，深度学习三者的关系 三者关系点击放大 \" 三者关系 人工智能(AI) 一个笼统的概念，简单描述一门让机器好似有人类智慧的计算机学科。人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。 机器学习(Machine Learning) 顾名思义是一种让计算机自己学习的算法。在智能应用开发的早期，许多系统都是使用大量的if-else结构来进行决策和处理数据的，比如希望判断邮件是否为垃圾邮件，可能需要先创建一个类似敏感词库的东西，然后判断邮件的内容是否包含这些关键词，if包含则为垃圾邮件，else不是垃圾邮件。这样的系统在某些领域确实是非常简单且高效的，尤其在一些系统所有的输入和输出都是能够被人们掌握的情况下。但是这种靠if-else的人为决策，明显很难对任务的变化进行自适应，且在开发系统时需对该系统将要处理的各种场景了如指掌。就像你很难用if-else来写一个人脸检测系统。 成功的机器学习算法是能够将决策过程自动化的那些算法，而这些决策过程是通过大量的数据输入(即已知的示例)中泛化得出的。 通常任何问题都可以用 $y=f(x)$ 模型或概率模型$P(Y|X)$ 表示，而机器学习的最终结果就是求出这个决策函数 $f(x)$ 或条件概率分布 $P(Y|X)$ 基本概念 ","date":"2020-01-28","objectID":"/ml/:0:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"样本数据 上面说到机器学习最终目的是求出 $y=f(x)$ 这个模型，样本数据便是一些已知的 $(x, y)$ 或者只有 $x$。其中 $x$ 叫做输入数据，$y$ 叫做输出数据（或者叫标签、标注）。$x$ 和 $y$可以是多维的可以包含多个特征。例如输入实例$x$的特征向量记作 $$ x= (x^{(1)}, x^{(2)}, x^{(3)}, \\ldots, x^{(i)}, \\ldots, x^{(n)})^T $$ $x^{(1)}$ 表示 $x$ 的第 $i$ 个特征。而 $x_i$表示多个输入中的第i个输入，即 $$ x_i = (x_{i}^{(1)}, x_{i}^{(2)}, x_{i}^{(3)}, \\ldots, x_{i}^{(n)}) $$ ","date":"2020-01-28","objectID":"/ml/:1:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"数据集 完整的数据集表示为 $T = \\lbrace(x_1, y_1), (x_2, y_2), (x_3, y_3), \\ldots, (x_n, y_n)\\rbrace$，并不是所有的数据都将用于模型训练，通常数据集会被分为三个部分：训练集、验证集、测试集 训练集：用于训练学习模型，通常比例不低于总数据量的50% 验证集：用于衡量训练过程中模型的好坏，通过不断迭代来优化模型 测试集：验证集智能用于监视和辅助模型训练，不能用来代表模型的好坏，哪怕验证的准确率是100%测试集也有可能是10%的准确率，这时的模型也是不能被接受的 ","date":"2020-01-28","objectID":"/ml/:2:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"特征 特征是机器学习和模式识别领域一个比较特有的名词，在传统机器学习算法中，由于计算性能和参数的限制，所以输入的数据维数不能太高。我们手机随随便便一张照片就有几个MB的数据量，可能会有几百万个像素，这么高维的数据量我们是不能直接输入给学习机的，因此我们需要针对特别的应用提取相对应的特征向量，特征向量的作用主要有两个： 降低数据维度：通过提取特征向量，把原始数据的维度大大较低，简化模型的参数数量 提升模型性能：一个好的特征，可以提前把原始数据最关键的部分提取出来，因此可以提高学习机的性能 用于模型训练的每一个具体输入实例通常由特征向量表示，人工拆解特征的方法即所谓的特征工程，而深度学习算法自动将概念拆解成特征向量，免去的传统机器算法拆解特征这个步骤 机器学习基本分类 ","date":"2020-01-28","objectID":"/ml/:3:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"监督学习 监督学习是指从带有标注的训练数据中学习预测模型的机器学习问题。标注数据表示输入输出的对应关系，预测模型对给定的输入产生相应的输出。其本质是学习输入到输出映射的统计规律。 通常分为学习和预测两个过程，学习系统利用给定的训练数据集通过学习（或者说训练）得到一个模型，预测系统对给定的测试样本集的输入得出相应的输出。 问题分类： 输入变量 $X$ 和输出变量 $Y$有不同的类型，可以是连续的，也可以是离散的。根据输入输出的不同类型，对预测任务给予了不同的名称： 分类问题：输出变量为有限个离散变量 回归问题：输入变量与输出变量均为连续 标注问题：输入变量与输出变量均为变量序列 ","date":"2020-01-28","objectID":"/ml/:4:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"非监督学习 非监督学习算法或者说无监督算法与监督学习算法的区别就在于，训练数据中只有输入是已知的，但是并没有为算法提供预期输出。需要算法自行总结数据中的规律，做出符合预期的判断。所以这类算法的理解和评估确实往往比较困难。 非监督学习算法可用于对已有数据的分析，也可以用于对未来数据的预测，与监督学习类似由学习系统和预测系统完成，其本质是学习数据中的统计规律或潜在结构。 非监督学习的两类算法： 聚类算法：根据数据的“相似性”将数据分为多类的过程，将数据集分成一个个的簇cluster（也可以理解为一组一组的形式） 降维算法：即在保证数据所具有的代表性特性或者分布的情况下，将高维数据转化为低维数据的过程（数据的可视化和精简数据） 非监督算法实例： 一家广告平台需要根据相似的人口学特征和购买习惯将美国人口分成不同的小组，以便广告客户可以通过有关联的广告接触到他们的目标客户 Airbnb 需要将自己的房屋清单分组成不同的社区，以便用户能更轻松地查阅这些清单 一个数据科学团队需要降低一个大型数据集的维度的数量，以便简化建模和降低文件大小 ","date":"2020-01-28","objectID":"/ml/:5:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"强化学习 强化学习指智能系统在与环境互动中学习最优行为策略的机器学习问题，本质是学习最优的序贯决策。学习过程中，系统不断的试错，已达到学习最优策略的目的。 大名鼎鼎的AlphaGo背后就有这强化学习算法的支持。 ","date":"2020-01-28","objectID":"/ml/:6:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"半监督学习和自动学习 半监督学习：指利用标注数据和未标注数据学习，通常少量标注数据，大量未标注数据。因为标注数据的构建往往需要大量的人工，成本较高，未标注数据的收集则不需要太多成本。旨在利用未标注数据中的信息，辅助标注数据，进行监督学习，以较低的成本达到较好的学习效果 自动学习：指机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。通常的监督学习使用给定的标注数据往往是随机得到的，可以看做是”被动学习“，主动学习的目标是找出对学习最有帮助的实例让教师标注，以较小的标注代价，达到更好的学习效果 半监督学习和主动学习更接近监督学习 机器学习算法三要素 ","date":"2020-01-28","objectID":"/ml/:7:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"模型 模型是机器学习的最终结果，即上面所说的决策函数 $y=f(x)$ 或条件概率分布 $P(Y|X)$，它被用来预测特定问题下的某个输入对应的输出结果。而所有可能的决策函数或条件概率分布的集合便称为假设空间 ","date":"2020-01-28","objectID":"/ml/:8:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"策略 有了模型的假设空间，机器学习接着需要考虑按照什么样的准则学习或选择最优的模型。机器学习的目标便是从假设空间中选取最优模型。而最优的定义则由我们所选则的评价准则定义的，即我们选取的模型的策略。通常评价模型在某个样本点的好坏用损失函数 $L(Y, f(X))$ 表示，而对所有样本预测的平均好坏用风险函数 $R_{exp}(f) = E[L(Y, f(X))]$ 表示 ","date":"2020-01-28","objectID":"/ml/:9:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"},{"categories":["人工智能"],"content":"算法 算法指学习模型的具体计算方法。机器学习基于训练数据集，根据学校策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型 这时，机器学习问题归结为最优化问题，机器学习的算法成为求解最优化问题的算法。例如，当已经知道问题模型属于权值向量参数未定的线性决策函数，那么确定一个经验风险最小化的权值向量的过程就是这次学习的算法 机器学习方法之间的不同，主要来自其模型、策略、算法的不同。确定了模型、策略、算法，机器学习的方法也就确定了。这就是将其称为机器学习方法三要素的原因 深度学习(Deep Learning) 讲深度学习前先讲讲神经网络，传统神经网络也是机器学习算法中的一员。而深度学习涉及训练多层神经网络，也称为深度神经网络。 未完待续… ","date":"2020-01-28","objectID":"/ml/:10:0","tags":["人工智能","机器学习"],"title":"机器学习初体验","uri":"/ml/"}]